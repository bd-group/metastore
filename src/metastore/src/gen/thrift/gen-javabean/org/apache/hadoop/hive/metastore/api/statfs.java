/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package org.apache.hadoop.hive.metastore.api;

import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class statfs implements org.apache.thrift.TBase<statfs, statfs._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("statfs");

  private static final org.apache.thrift.protocol.TField FROM_FIELD_DESC = new org.apache.thrift.protocol.TField("from", org.apache.thrift.protocol.TType.I64, (short)1);
  private static final org.apache.thrift.protocol.TField TO_FIELD_DESC = new org.apache.thrift.protocol.TField("to", org.apache.thrift.protocol.TType.I64, (short)2);
  private static final org.apache.thrift.protocol.TField INCREATE_FIELD_DESC = new org.apache.thrift.protocol.TField("increate", org.apache.thrift.protocol.TType.I64, (short)3);
  private static final org.apache.thrift.protocol.TField CLOSE_FIELD_DESC = new org.apache.thrift.protocol.TField("close", org.apache.thrift.protocol.TType.I64, (short)4);
  private static final org.apache.thrift.protocol.TField REPLICATED_FIELD_DESC = new org.apache.thrift.protocol.TField("replicated", org.apache.thrift.protocol.TType.I64, (short)5);
  private static final org.apache.thrift.protocol.TField RM_LOGICAL_FIELD_DESC = new org.apache.thrift.protocol.TField("rm_logical", org.apache.thrift.protocol.TType.I64, (short)6);
  private static final org.apache.thrift.protocol.TField RM_PHYSICAL_FIELD_DESC = new org.apache.thrift.protocol.TField("rm_physical", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField UNDERREP_FIELD_DESC = new org.apache.thrift.protocol.TField("underrep", org.apache.thrift.protocol.TType.I64, (short)8);
  private static final org.apache.thrift.protocol.TField OVERREP_FIELD_DESC = new org.apache.thrift.protocol.TField("overrep", org.apache.thrift.protocol.TType.I64, (short)9);
  private static final org.apache.thrift.protocol.TField LINGER_FIELD_DESC = new org.apache.thrift.protocol.TField("linger", org.apache.thrift.protocol.TType.I64, (short)10);
  private static final org.apache.thrift.protocol.TField SUSPECT_FIELD_DESC = new org.apache.thrift.protocol.TField("suspect", org.apache.thrift.protocol.TType.I64, (short)11);
  private static final org.apache.thrift.protocol.TField INC_ONS_FIELD_DESC = new org.apache.thrift.protocol.TField("inc_ons", org.apache.thrift.protocol.TType.I64, (short)12);
  private static final org.apache.thrift.protocol.TField INC_ONS2_FIELD_DESC = new org.apache.thrift.protocol.TField("inc_ons2", org.apache.thrift.protocol.TType.I64, (short)13);
  private static final org.apache.thrift.protocol.TField CLS_OFFS_FIELD_DESC = new org.apache.thrift.protocol.TField("cls_offs", org.apache.thrift.protocol.TType.I64, (short)14);
  private static final org.apache.thrift.protocol.TField INCS_FIELD_DESC = new org.apache.thrift.protocol.TField("incs", org.apache.thrift.protocol.TType.LIST, (short)15);
  private static final org.apache.thrift.protocol.TField CLOS_FIELD_DESC = new org.apache.thrift.protocol.TField("clos", org.apache.thrift.protocol.TType.LIST, (short)16);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new statfsStandardSchemeFactory());
    schemes.put(TupleScheme.class, new statfsTupleSchemeFactory());
  }

  private long from; // required
  private long to; // required
  private long increate; // required
  private long close; // required
  private long replicated; // required
  private long rm_logical; // required
  private long rm_physical; // required
  private long underrep; // required
  private long overrep; // required
  private long linger; // required
  private long suspect; // required
  private long inc_ons; // required
  private long inc_ons2; // required
  private long cls_offs; // required
  private List<Long> incs; // required
  private List<Long> clos; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    FROM((short)1, "from"),
    TO((short)2, "to"),
    INCREATE((short)3, "increate"),
    CLOSE((short)4, "close"),
    REPLICATED((short)5, "replicated"),
    RM_LOGICAL((short)6, "rm_logical"),
    RM_PHYSICAL((short)7, "rm_physical"),
    UNDERREP((short)8, "underrep"),
    OVERREP((short)9, "overrep"),
    LINGER((short)10, "linger"),
    SUSPECT((short)11, "suspect"),
    INC_ONS((short)12, "inc_ons"),
    INC_ONS2((short)13, "inc_ons2"),
    CLS_OFFS((short)14, "cls_offs"),
    INCS((short)15, "incs"),
    CLOS((short)16, "clos");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // FROM
          return FROM;
        case 2: // TO
          return TO;
        case 3: // INCREATE
          return INCREATE;
        case 4: // CLOSE
          return CLOSE;
        case 5: // REPLICATED
          return REPLICATED;
        case 6: // RM_LOGICAL
          return RM_LOGICAL;
        case 7: // RM_PHYSICAL
          return RM_PHYSICAL;
        case 8: // UNDERREP
          return UNDERREP;
        case 9: // OVERREP
          return OVERREP;
        case 10: // LINGER
          return LINGER;
        case 11: // SUSPECT
          return SUSPECT;
        case 12: // INC_ONS
          return INC_ONS;
        case 13: // INC_ONS2
          return INC_ONS2;
        case 14: // CLS_OFFS
          return CLS_OFFS;
        case 15: // INCS
          return INCS;
        case 16: // CLOS
          return CLOS;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __FROM_ISSET_ID = 0;
  private static final int __TO_ISSET_ID = 1;
  private static final int __INCREATE_ISSET_ID = 2;
  private static final int __CLOSE_ISSET_ID = 3;
  private static final int __REPLICATED_ISSET_ID = 4;
  private static final int __RM_LOGICAL_ISSET_ID = 5;
  private static final int __RM_PHYSICAL_ISSET_ID = 6;
  private static final int __UNDERREP_ISSET_ID = 7;
  private static final int __OVERREP_ISSET_ID = 8;
  private static final int __LINGER_ISSET_ID = 9;
  private static final int __SUSPECT_ISSET_ID = 10;
  private static final int __INC_ONS_ISSET_ID = 11;
  private static final int __INC_ONS2_ISSET_ID = 12;
  private static final int __CLS_OFFS_ISSET_ID = 13;
  private short __isset_bitfield = 0;
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.FROM, new org.apache.thrift.meta_data.FieldMetaData("from", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.TO, new org.apache.thrift.meta_data.FieldMetaData("to", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.INCREATE, new org.apache.thrift.meta_data.FieldMetaData("increate", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.CLOSE, new org.apache.thrift.meta_data.FieldMetaData("close", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REPLICATED, new org.apache.thrift.meta_data.FieldMetaData("replicated", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.RM_LOGICAL, new org.apache.thrift.meta_data.FieldMetaData("rm_logical", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.RM_PHYSICAL, new org.apache.thrift.meta_data.FieldMetaData("rm_physical", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.UNDERREP, new org.apache.thrift.meta_data.FieldMetaData("underrep", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.OVERREP, new org.apache.thrift.meta_data.FieldMetaData("overrep", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.LINGER, new org.apache.thrift.meta_data.FieldMetaData("linger", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.SUSPECT, new org.apache.thrift.meta_data.FieldMetaData("suspect", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.INC_ONS, new org.apache.thrift.meta_data.FieldMetaData("inc_ons", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.INC_ONS2, new org.apache.thrift.meta_data.FieldMetaData("inc_ons2", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.CLS_OFFS, new org.apache.thrift.meta_data.FieldMetaData("cls_offs", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.INCS, new org.apache.thrift.meta_data.FieldMetaData("incs", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64))));
    tmpMap.put(_Fields.CLOS, new org.apache.thrift.meta_data.FieldMetaData("clos", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64))));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(statfs.class, metaDataMap);
  }

  public statfs() {
  }

  public statfs(
    long from,
    long to,
    long increate,
    long close,
    long replicated,
    long rm_logical,
    long rm_physical,
    long underrep,
    long overrep,
    long linger,
    long suspect,
    long inc_ons,
    long inc_ons2,
    long cls_offs,
    List<Long> incs,
    List<Long> clos)
  {
    this();
    this.from = from;
    setFromIsSet(true);
    this.to = to;
    setToIsSet(true);
    this.increate = increate;
    setIncreateIsSet(true);
    this.close = close;
    setCloseIsSet(true);
    this.replicated = replicated;
    setReplicatedIsSet(true);
    this.rm_logical = rm_logical;
    setRm_logicalIsSet(true);
    this.rm_physical = rm_physical;
    setRm_physicalIsSet(true);
    this.underrep = underrep;
    setUnderrepIsSet(true);
    this.overrep = overrep;
    setOverrepIsSet(true);
    this.linger = linger;
    setLingerIsSet(true);
    this.suspect = suspect;
    setSuspectIsSet(true);
    this.inc_ons = inc_ons;
    setInc_onsIsSet(true);
    this.inc_ons2 = inc_ons2;
    setInc_ons2IsSet(true);
    this.cls_offs = cls_offs;
    setCls_offsIsSet(true);
    this.incs = incs;
    this.clos = clos;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public statfs(statfs other) {
    __isset_bitfield = other.__isset_bitfield;
    this.from = other.from;
    this.to = other.to;
    this.increate = other.increate;
    this.close = other.close;
    this.replicated = other.replicated;
    this.rm_logical = other.rm_logical;
    this.rm_physical = other.rm_physical;
    this.underrep = other.underrep;
    this.overrep = other.overrep;
    this.linger = other.linger;
    this.suspect = other.suspect;
    this.inc_ons = other.inc_ons;
    this.inc_ons2 = other.inc_ons2;
    this.cls_offs = other.cls_offs;
    if (other.isSetIncs()) {
      List<Long> __this__incs = new ArrayList<Long>();
      for (Long other_element : other.incs) {
        __this__incs.add(other_element);
      }
      this.incs = __this__incs;
    }
    if (other.isSetClos()) {
      List<Long> __this__clos = new ArrayList<Long>();
      for (Long other_element : other.clos) {
        __this__clos.add(other_element);
      }
      this.clos = __this__clos;
    }
  }

  public statfs deepCopy() {
    return new statfs(this);
  }

  @Override
  public void clear() {
    setFromIsSet(false);
    this.from = 0;
    setToIsSet(false);
    this.to = 0;
    setIncreateIsSet(false);
    this.increate = 0;
    setCloseIsSet(false);
    this.close = 0;
    setReplicatedIsSet(false);
    this.replicated = 0;
    setRm_logicalIsSet(false);
    this.rm_logical = 0;
    setRm_physicalIsSet(false);
    this.rm_physical = 0;
    setUnderrepIsSet(false);
    this.underrep = 0;
    setOverrepIsSet(false);
    this.overrep = 0;
    setLingerIsSet(false);
    this.linger = 0;
    setSuspectIsSet(false);
    this.suspect = 0;
    setInc_onsIsSet(false);
    this.inc_ons = 0;
    setInc_ons2IsSet(false);
    this.inc_ons2 = 0;
    setCls_offsIsSet(false);
    this.cls_offs = 0;
    this.incs = null;
    this.clos = null;
  }

  public long getFrom() {
    return this.from;
  }

  public void setFrom(long from) {
    this.from = from;
    setFromIsSet(true);
  }

  public void unsetFrom() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __FROM_ISSET_ID);
  }

  /** Returns true if field from is set (has been assigned a value) and false otherwise */
  public boolean isSetFrom() {
    return EncodingUtils.testBit(__isset_bitfield, __FROM_ISSET_ID);
  }

  public void setFromIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __FROM_ISSET_ID, value);
  }

  public long getTo() {
    return this.to;
  }

  public void setTo(long to) {
    this.to = to;
    setToIsSet(true);
  }

  public void unsetTo() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __TO_ISSET_ID);
  }

  /** Returns true if field to is set (has been assigned a value) and false otherwise */
  public boolean isSetTo() {
    return EncodingUtils.testBit(__isset_bitfield, __TO_ISSET_ID);
  }

  public void setToIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __TO_ISSET_ID, value);
  }

  public long getIncreate() {
    return this.increate;
  }

  public void setIncreate(long increate) {
    this.increate = increate;
    setIncreateIsSet(true);
  }

  public void unsetIncreate() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __INCREATE_ISSET_ID);
  }

  /** Returns true if field increate is set (has been assigned a value) and false otherwise */
  public boolean isSetIncreate() {
    return EncodingUtils.testBit(__isset_bitfield, __INCREATE_ISSET_ID);
  }

  public void setIncreateIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __INCREATE_ISSET_ID, value);
  }

  public long getClose() {
    return this.close;
  }

  public void setClose(long close) {
    this.close = close;
    setCloseIsSet(true);
  }

  public void unsetClose() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CLOSE_ISSET_ID);
  }

  /** Returns true if field close is set (has been assigned a value) and false otherwise */
  public boolean isSetClose() {
    return EncodingUtils.testBit(__isset_bitfield, __CLOSE_ISSET_ID);
  }

  public void setCloseIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CLOSE_ISSET_ID, value);
  }

  public long getReplicated() {
    return this.replicated;
  }

  public void setReplicated(long replicated) {
    this.replicated = replicated;
    setReplicatedIsSet(true);
  }

  public void unsetReplicated() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REPLICATED_ISSET_ID);
  }

  /** Returns true if field replicated is set (has been assigned a value) and false otherwise */
  public boolean isSetReplicated() {
    return EncodingUtils.testBit(__isset_bitfield, __REPLICATED_ISSET_ID);
  }

  public void setReplicatedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REPLICATED_ISSET_ID, value);
  }

  public long getRm_logical() {
    return this.rm_logical;
  }

  public void setRm_logical(long rm_logical) {
    this.rm_logical = rm_logical;
    setRm_logicalIsSet(true);
  }

  public void unsetRm_logical() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RM_LOGICAL_ISSET_ID);
  }

  /** Returns true if field rm_logical is set (has been assigned a value) and false otherwise */
  public boolean isSetRm_logical() {
    return EncodingUtils.testBit(__isset_bitfield, __RM_LOGICAL_ISSET_ID);
  }

  public void setRm_logicalIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RM_LOGICAL_ISSET_ID, value);
  }

  public long getRm_physical() {
    return this.rm_physical;
  }

  public void setRm_physical(long rm_physical) {
    this.rm_physical = rm_physical;
    setRm_physicalIsSet(true);
  }

  public void unsetRm_physical() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RM_PHYSICAL_ISSET_ID);
  }

  /** Returns true if field rm_physical is set (has been assigned a value) and false otherwise */
  public boolean isSetRm_physical() {
    return EncodingUtils.testBit(__isset_bitfield, __RM_PHYSICAL_ISSET_ID);
  }

  public void setRm_physicalIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RM_PHYSICAL_ISSET_ID, value);
  }

  public long getUnderrep() {
    return this.underrep;
  }

  public void setUnderrep(long underrep) {
    this.underrep = underrep;
    setUnderrepIsSet(true);
  }

  public void unsetUnderrep() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __UNDERREP_ISSET_ID);
  }

  /** Returns true if field underrep is set (has been assigned a value) and false otherwise */
  public boolean isSetUnderrep() {
    return EncodingUtils.testBit(__isset_bitfield, __UNDERREP_ISSET_ID);
  }

  public void setUnderrepIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __UNDERREP_ISSET_ID, value);
  }

  public long getOverrep() {
    return this.overrep;
  }

  public void setOverrep(long overrep) {
    this.overrep = overrep;
    setOverrepIsSet(true);
  }

  public void unsetOverrep() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __OVERREP_ISSET_ID);
  }

  /** Returns true if field overrep is set (has been assigned a value) and false otherwise */
  public boolean isSetOverrep() {
    return EncodingUtils.testBit(__isset_bitfield, __OVERREP_ISSET_ID);
  }

  public void setOverrepIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __OVERREP_ISSET_ID, value);
  }

  public long getLinger() {
    return this.linger;
  }

  public void setLinger(long linger) {
    this.linger = linger;
    setLingerIsSet(true);
  }

  public void unsetLinger() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LINGER_ISSET_ID);
  }

  /** Returns true if field linger is set (has been assigned a value) and false otherwise */
  public boolean isSetLinger() {
    return EncodingUtils.testBit(__isset_bitfield, __LINGER_ISSET_ID);
  }

  public void setLingerIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LINGER_ISSET_ID, value);
  }

  public long getSuspect() {
    return this.suspect;
  }

  public void setSuspect(long suspect) {
    this.suspect = suspect;
    setSuspectIsSet(true);
  }

  public void unsetSuspect() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUSPECT_ISSET_ID);
  }

  /** Returns true if field suspect is set (has been assigned a value) and false otherwise */
  public boolean isSetSuspect() {
    return EncodingUtils.testBit(__isset_bitfield, __SUSPECT_ISSET_ID);
  }

  public void setSuspectIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUSPECT_ISSET_ID, value);
  }

  public long getInc_ons() {
    return this.inc_ons;
  }

  public void setInc_ons(long inc_ons) {
    this.inc_ons = inc_ons;
    setInc_onsIsSet(true);
  }

  public void unsetInc_ons() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __INC_ONS_ISSET_ID);
  }

  /** Returns true if field inc_ons is set (has been assigned a value) and false otherwise */
  public boolean isSetInc_ons() {
    return EncodingUtils.testBit(__isset_bitfield, __INC_ONS_ISSET_ID);
  }

  public void setInc_onsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __INC_ONS_ISSET_ID, value);
  }

  public long getInc_ons2() {
    return this.inc_ons2;
  }

  public void setInc_ons2(long inc_ons2) {
    this.inc_ons2 = inc_ons2;
    setInc_ons2IsSet(true);
  }

  public void unsetInc_ons2() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __INC_ONS2_ISSET_ID);
  }

  /** Returns true if field inc_ons2 is set (has been assigned a value) and false otherwise */
  public boolean isSetInc_ons2() {
    return EncodingUtils.testBit(__isset_bitfield, __INC_ONS2_ISSET_ID);
  }

  public void setInc_ons2IsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __INC_ONS2_ISSET_ID, value);
  }

  public long getCls_offs() {
    return this.cls_offs;
  }

  public void setCls_offs(long cls_offs) {
    this.cls_offs = cls_offs;
    setCls_offsIsSet(true);
  }

  public void unsetCls_offs() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CLS_OFFS_ISSET_ID);
  }

  /** Returns true if field cls_offs is set (has been assigned a value) and false otherwise */
  public boolean isSetCls_offs() {
    return EncodingUtils.testBit(__isset_bitfield, __CLS_OFFS_ISSET_ID);
  }

  public void setCls_offsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CLS_OFFS_ISSET_ID, value);
  }

  public int getIncsSize() {
    return (this.incs == null) ? 0 : this.incs.size();
  }

  public java.util.Iterator<Long> getIncsIterator() {
    return (this.incs == null) ? null : this.incs.iterator();
  }

  public void addToIncs(long elem) {
    if (this.incs == null) {
      this.incs = new ArrayList<Long>();
    }
    this.incs.add(elem);
  }

  public List<Long> getIncs() {
    return this.incs;
  }

  public void setIncs(List<Long> incs) {
    this.incs = incs;
  }

  public void unsetIncs() {
    this.incs = null;
  }

  /** Returns true if field incs is set (has been assigned a value) and false otherwise */
  public boolean isSetIncs() {
    return this.incs != null;
  }

  public void setIncsIsSet(boolean value) {
    if (!value) {
      this.incs = null;
    }
  }

  public int getClosSize() {
    return (this.clos == null) ? 0 : this.clos.size();
  }

  public java.util.Iterator<Long> getClosIterator() {
    return (this.clos == null) ? null : this.clos.iterator();
  }

  public void addToClos(long elem) {
    if (this.clos == null) {
      this.clos = new ArrayList<Long>();
    }
    this.clos.add(elem);
  }

  public List<Long> getClos() {
    return this.clos;
  }

  public void setClos(List<Long> clos) {
    this.clos = clos;
  }

  public void unsetClos() {
    this.clos = null;
  }

  /** Returns true if field clos is set (has been assigned a value) and false otherwise */
  public boolean isSetClos() {
    return this.clos != null;
  }

  public void setClosIsSet(boolean value) {
    if (!value) {
      this.clos = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case FROM:
      if (value == null) {
        unsetFrom();
      } else {
        setFrom((Long)value);
      }
      break;

    case TO:
      if (value == null) {
        unsetTo();
      } else {
        setTo((Long)value);
      }
      break;

    case INCREATE:
      if (value == null) {
        unsetIncreate();
      } else {
        setIncreate((Long)value);
      }
      break;

    case CLOSE:
      if (value == null) {
        unsetClose();
      } else {
        setClose((Long)value);
      }
      break;

    case REPLICATED:
      if (value == null) {
        unsetReplicated();
      } else {
        setReplicated((Long)value);
      }
      break;

    case RM_LOGICAL:
      if (value == null) {
        unsetRm_logical();
      } else {
        setRm_logical((Long)value);
      }
      break;

    case RM_PHYSICAL:
      if (value == null) {
        unsetRm_physical();
      } else {
        setRm_physical((Long)value);
      }
      break;

    case UNDERREP:
      if (value == null) {
        unsetUnderrep();
      } else {
        setUnderrep((Long)value);
      }
      break;

    case OVERREP:
      if (value == null) {
        unsetOverrep();
      } else {
        setOverrep((Long)value);
      }
      break;

    case LINGER:
      if (value == null) {
        unsetLinger();
      } else {
        setLinger((Long)value);
      }
      break;

    case SUSPECT:
      if (value == null) {
        unsetSuspect();
      } else {
        setSuspect((Long)value);
      }
      break;

    case INC_ONS:
      if (value == null) {
        unsetInc_ons();
      } else {
        setInc_ons((Long)value);
      }
      break;

    case INC_ONS2:
      if (value == null) {
        unsetInc_ons2();
      } else {
        setInc_ons2((Long)value);
      }
      break;

    case CLS_OFFS:
      if (value == null) {
        unsetCls_offs();
      } else {
        setCls_offs((Long)value);
      }
      break;

    case INCS:
      if (value == null) {
        unsetIncs();
      } else {
        setIncs((List<Long>)value);
      }
      break;

    case CLOS:
      if (value == null) {
        unsetClos();
      } else {
        setClos((List<Long>)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case FROM:
      return Long.valueOf(getFrom());

    case TO:
      return Long.valueOf(getTo());

    case INCREATE:
      return Long.valueOf(getIncreate());

    case CLOSE:
      return Long.valueOf(getClose());

    case REPLICATED:
      return Long.valueOf(getReplicated());

    case RM_LOGICAL:
      return Long.valueOf(getRm_logical());

    case RM_PHYSICAL:
      return Long.valueOf(getRm_physical());

    case UNDERREP:
      return Long.valueOf(getUnderrep());

    case OVERREP:
      return Long.valueOf(getOverrep());

    case LINGER:
      return Long.valueOf(getLinger());

    case SUSPECT:
      return Long.valueOf(getSuspect());

    case INC_ONS:
      return Long.valueOf(getInc_ons());

    case INC_ONS2:
      return Long.valueOf(getInc_ons2());

    case CLS_OFFS:
      return Long.valueOf(getCls_offs());

    case INCS:
      return getIncs();

    case CLOS:
      return getClos();

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case FROM:
      return isSetFrom();
    case TO:
      return isSetTo();
    case INCREATE:
      return isSetIncreate();
    case CLOSE:
      return isSetClose();
    case REPLICATED:
      return isSetReplicated();
    case RM_LOGICAL:
      return isSetRm_logical();
    case RM_PHYSICAL:
      return isSetRm_physical();
    case UNDERREP:
      return isSetUnderrep();
    case OVERREP:
      return isSetOverrep();
    case LINGER:
      return isSetLinger();
    case SUSPECT:
      return isSetSuspect();
    case INC_ONS:
      return isSetInc_ons();
    case INC_ONS2:
      return isSetInc_ons2();
    case CLS_OFFS:
      return isSetCls_offs();
    case INCS:
      return isSetIncs();
    case CLOS:
      return isSetClos();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof statfs)
      return this.equals((statfs)that);
    return false;
  }

  public boolean equals(statfs that) {
    if (that == null)
      return false;

    boolean this_present_from = true;
    boolean that_present_from = true;
    if (this_present_from || that_present_from) {
      if (!(this_present_from && that_present_from))
        return false;
      if (this.from != that.from)
        return false;
    }

    boolean this_present_to = true;
    boolean that_present_to = true;
    if (this_present_to || that_present_to) {
      if (!(this_present_to && that_present_to))
        return false;
      if (this.to != that.to)
        return false;
    }

    boolean this_present_increate = true;
    boolean that_present_increate = true;
    if (this_present_increate || that_present_increate) {
      if (!(this_present_increate && that_present_increate))
        return false;
      if (this.increate != that.increate)
        return false;
    }

    boolean this_present_close = true;
    boolean that_present_close = true;
    if (this_present_close || that_present_close) {
      if (!(this_present_close && that_present_close))
        return false;
      if (this.close != that.close)
        return false;
    }

    boolean this_present_replicated = true;
    boolean that_present_replicated = true;
    if (this_present_replicated || that_present_replicated) {
      if (!(this_present_replicated && that_present_replicated))
        return false;
      if (this.replicated != that.replicated)
        return false;
    }

    boolean this_present_rm_logical = true;
    boolean that_present_rm_logical = true;
    if (this_present_rm_logical || that_present_rm_logical) {
      if (!(this_present_rm_logical && that_present_rm_logical))
        return false;
      if (this.rm_logical != that.rm_logical)
        return false;
    }

    boolean this_present_rm_physical = true;
    boolean that_present_rm_physical = true;
    if (this_present_rm_physical || that_present_rm_physical) {
      if (!(this_present_rm_physical && that_present_rm_physical))
        return false;
      if (this.rm_physical != that.rm_physical)
        return false;
    }

    boolean this_present_underrep = true;
    boolean that_present_underrep = true;
    if (this_present_underrep || that_present_underrep) {
      if (!(this_present_underrep && that_present_underrep))
        return false;
      if (this.underrep != that.underrep)
        return false;
    }

    boolean this_present_overrep = true;
    boolean that_present_overrep = true;
    if (this_present_overrep || that_present_overrep) {
      if (!(this_present_overrep && that_present_overrep))
        return false;
      if (this.overrep != that.overrep)
        return false;
    }

    boolean this_present_linger = true;
    boolean that_present_linger = true;
    if (this_present_linger || that_present_linger) {
      if (!(this_present_linger && that_present_linger))
        return false;
      if (this.linger != that.linger)
        return false;
    }

    boolean this_present_suspect = true;
    boolean that_present_suspect = true;
    if (this_present_suspect || that_present_suspect) {
      if (!(this_present_suspect && that_present_suspect))
        return false;
      if (this.suspect != that.suspect)
        return false;
    }

    boolean this_present_inc_ons = true;
    boolean that_present_inc_ons = true;
    if (this_present_inc_ons || that_present_inc_ons) {
      if (!(this_present_inc_ons && that_present_inc_ons))
        return false;
      if (this.inc_ons != that.inc_ons)
        return false;
    }

    boolean this_present_inc_ons2 = true;
    boolean that_present_inc_ons2 = true;
    if (this_present_inc_ons2 || that_present_inc_ons2) {
      if (!(this_present_inc_ons2 && that_present_inc_ons2))
        return false;
      if (this.inc_ons2 != that.inc_ons2)
        return false;
    }

    boolean this_present_cls_offs = true;
    boolean that_present_cls_offs = true;
    if (this_present_cls_offs || that_present_cls_offs) {
      if (!(this_present_cls_offs && that_present_cls_offs))
        return false;
      if (this.cls_offs != that.cls_offs)
        return false;
    }

    boolean this_present_incs = true && this.isSetIncs();
    boolean that_present_incs = true && that.isSetIncs();
    if (this_present_incs || that_present_incs) {
      if (!(this_present_incs && that_present_incs))
        return false;
      if (!this.incs.equals(that.incs))
        return false;
    }

    boolean this_present_clos = true && this.isSetClos();
    boolean that_present_clos = true && that.isSetClos();
    if (this_present_clos || that_present_clos) {
      if (!(this_present_clos && that_present_clos))
        return false;
      if (!this.clos.equals(that.clos))
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    HashCodeBuilder builder = new HashCodeBuilder();

    boolean present_from = true;
    builder.append(present_from);
    if (present_from)
      builder.append(from);

    boolean present_to = true;
    builder.append(present_to);
    if (present_to)
      builder.append(to);

    boolean present_increate = true;
    builder.append(present_increate);
    if (present_increate)
      builder.append(increate);

    boolean present_close = true;
    builder.append(present_close);
    if (present_close)
      builder.append(close);

    boolean present_replicated = true;
    builder.append(present_replicated);
    if (present_replicated)
      builder.append(replicated);

    boolean present_rm_logical = true;
    builder.append(present_rm_logical);
    if (present_rm_logical)
      builder.append(rm_logical);

    boolean present_rm_physical = true;
    builder.append(present_rm_physical);
    if (present_rm_physical)
      builder.append(rm_physical);

    boolean present_underrep = true;
    builder.append(present_underrep);
    if (present_underrep)
      builder.append(underrep);

    boolean present_overrep = true;
    builder.append(present_overrep);
    if (present_overrep)
      builder.append(overrep);

    boolean present_linger = true;
    builder.append(present_linger);
    if (present_linger)
      builder.append(linger);

    boolean present_suspect = true;
    builder.append(present_suspect);
    if (present_suspect)
      builder.append(suspect);

    boolean present_inc_ons = true;
    builder.append(present_inc_ons);
    if (present_inc_ons)
      builder.append(inc_ons);

    boolean present_inc_ons2 = true;
    builder.append(present_inc_ons2);
    if (present_inc_ons2)
      builder.append(inc_ons2);

    boolean present_cls_offs = true;
    builder.append(present_cls_offs);
    if (present_cls_offs)
      builder.append(cls_offs);

    boolean present_incs = true && (isSetIncs());
    builder.append(present_incs);
    if (present_incs)
      builder.append(incs);

    boolean present_clos = true && (isSetClos());
    builder.append(present_clos);
    if (present_clos)
      builder.append(clos);

    return builder.toHashCode();
  }

  public int compareTo(statfs other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    statfs typedOther = (statfs)other;

    lastComparison = Boolean.valueOf(isSetFrom()).compareTo(typedOther.isSetFrom());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetFrom()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.from, typedOther.from);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetTo()).compareTo(typedOther.isSetTo());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetTo()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.to, typedOther.to);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIncreate()).compareTo(typedOther.isSetIncreate());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIncreate()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.increate, typedOther.increate);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClose()).compareTo(typedOther.isSetClose());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClose()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.close, typedOther.close);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetReplicated()).compareTo(typedOther.isSetReplicated());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetReplicated()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.replicated, typedOther.replicated);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRm_logical()).compareTo(typedOther.isSetRm_logical());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRm_logical()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rm_logical, typedOther.rm_logical);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRm_physical()).compareTo(typedOther.isSetRm_physical());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRm_physical()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rm_physical, typedOther.rm_physical);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetUnderrep()).compareTo(typedOther.isSetUnderrep());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetUnderrep()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.underrep, typedOther.underrep);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetOverrep()).compareTo(typedOther.isSetOverrep());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetOverrep()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.overrep, typedOther.overrep);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLinger()).compareTo(typedOther.isSetLinger());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLinger()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.linger, typedOther.linger);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetSuspect()).compareTo(typedOther.isSetSuspect());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSuspect()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.suspect, typedOther.suspect);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInc_ons()).compareTo(typedOther.isSetInc_ons());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInc_ons()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.inc_ons, typedOther.inc_ons);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetInc_ons2()).compareTo(typedOther.isSetInc_ons2());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetInc_ons2()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.inc_ons2, typedOther.inc_ons2);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCls_offs()).compareTo(typedOther.isSetCls_offs());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCls_offs()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cls_offs, typedOther.cls_offs);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIncs()).compareTo(typedOther.isSetIncs());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIncs()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.incs, typedOther.incs);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClos()).compareTo(typedOther.isSetClos());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClos()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.clos, typedOther.clos);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("statfs(");
    boolean first = true;

    sb.append("from:");
    sb.append(this.from);
    first = false;
    if (!first) sb.append(", ");
    sb.append("to:");
    sb.append(this.to);
    first = false;
    if (!first) sb.append(", ");
    sb.append("increate:");
    sb.append(this.increate);
    first = false;
    if (!first) sb.append(", ");
    sb.append("close:");
    sb.append(this.close);
    first = false;
    if (!first) sb.append(", ");
    sb.append("replicated:");
    sb.append(this.replicated);
    first = false;
    if (!first) sb.append(", ");
    sb.append("rm_logical:");
    sb.append(this.rm_logical);
    first = false;
    if (!first) sb.append(", ");
    sb.append("rm_physical:");
    sb.append(this.rm_physical);
    first = false;
    if (!first) sb.append(", ");
    sb.append("underrep:");
    sb.append(this.underrep);
    first = false;
    if (!first) sb.append(", ");
    sb.append("overrep:");
    sb.append(this.overrep);
    first = false;
    if (!first) sb.append(", ");
    sb.append("linger:");
    sb.append(this.linger);
    first = false;
    if (!first) sb.append(", ");
    sb.append("suspect:");
    sb.append(this.suspect);
    first = false;
    if (!first) sb.append(", ");
    sb.append("inc_ons:");
    sb.append(this.inc_ons);
    first = false;
    if (!first) sb.append(", ");
    sb.append("inc_ons2:");
    sb.append(this.inc_ons2);
    first = false;
    if (!first) sb.append(", ");
    sb.append("cls_offs:");
    sb.append(this.cls_offs);
    first = false;
    if (!first) sb.append(", ");
    sb.append("incs:");
    if (this.incs == null) {
      sb.append("null");
    } else {
      sb.append(this.incs);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("clos:");
    if (this.clos == null) {
      sb.append("null");
    } else {
      sb.append(this.clos);
    }
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class statfsStandardSchemeFactory implements SchemeFactory {
    public statfsStandardScheme getScheme() {
      return new statfsStandardScheme();
    }
  }

  private static class statfsStandardScheme extends StandardScheme<statfs> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, statfs struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // FROM
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.from = iprot.readI64();
              struct.setFromIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // TO
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.to = iprot.readI64();
              struct.setToIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // INCREATE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.increate = iprot.readI64();
              struct.setIncreateIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // CLOSE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.close = iprot.readI64();
              struct.setCloseIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // REPLICATED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.replicated = iprot.readI64();
              struct.setReplicatedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // RM_LOGICAL
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.rm_logical = iprot.readI64();
              struct.setRm_logicalIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // RM_PHYSICAL
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.rm_physical = iprot.readI64();
              struct.setRm_physicalIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // UNDERREP
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.underrep = iprot.readI64();
              struct.setUnderrepIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // OVERREP
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.overrep = iprot.readI64();
              struct.setOverrepIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // LINGER
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.linger = iprot.readI64();
              struct.setLingerIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // SUSPECT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.suspect = iprot.readI64();
              struct.setSuspectIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // INC_ONS
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.inc_ons = iprot.readI64();
              struct.setInc_onsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // INC_ONS2
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.inc_ons2 = iprot.readI64();
              struct.setInc_ons2IsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // CLS_OFFS
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.cls_offs = iprot.readI64();
              struct.setCls_offsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // INCS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list78 = iprot.readListBegin();
                struct.incs = new ArrayList<Long>(_list78.size);
                for (int _i79 = 0; _i79 < _list78.size; ++_i79)
                {
                  long _elem80; // required
                  _elem80 = iprot.readI64();
                  struct.incs.add(_elem80);
                }
                iprot.readListEnd();
              }
              struct.setIncsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // CLOS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list81 = iprot.readListBegin();
                struct.clos = new ArrayList<Long>(_list81.size);
                for (int _i82 = 0; _i82 < _list81.size; ++_i82)
                {
                  long _elem83; // required
                  _elem83 = iprot.readI64();
                  struct.clos.add(_elem83);
                }
                iprot.readListEnd();
              }
              struct.setClosIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, statfs struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(FROM_FIELD_DESC);
      oprot.writeI64(struct.from);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(TO_FIELD_DESC);
      oprot.writeI64(struct.to);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(INCREATE_FIELD_DESC);
      oprot.writeI64(struct.increate);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CLOSE_FIELD_DESC);
      oprot.writeI64(struct.close);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REPLICATED_FIELD_DESC);
      oprot.writeI64(struct.replicated);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RM_LOGICAL_FIELD_DESC);
      oprot.writeI64(struct.rm_logical);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RM_PHYSICAL_FIELD_DESC);
      oprot.writeI64(struct.rm_physical);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(UNDERREP_FIELD_DESC);
      oprot.writeI64(struct.underrep);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(OVERREP_FIELD_DESC);
      oprot.writeI64(struct.overrep);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LINGER_FIELD_DESC);
      oprot.writeI64(struct.linger);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SUSPECT_FIELD_DESC);
      oprot.writeI64(struct.suspect);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(INC_ONS_FIELD_DESC);
      oprot.writeI64(struct.inc_ons);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(INC_ONS2_FIELD_DESC);
      oprot.writeI64(struct.inc_ons2);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CLS_OFFS_FIELD_DESC);
      oprot.writeI64(struct.cls_offs);
      oprot.writeFieldEnd();
      if (struct.incs != null) {
        oprot.writeFieldBegin(INCS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I64, struct.incs.size()));
          for (long _iter84 : struct.incs)
          {
            oprot.writeI64(_iter84);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (struct.clos != null) {
        oprot.writeFieldBegin(CLOS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I64, struct.clos.size()));
          for (long _iter85 : struct.clos)
          {
            oprot.writeI64(_iter85);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class statfsTupleSchemeFactory implements SchemeFactory {
    public statfsTupleScheme getScheme() {
      return new statfsTupleScheme();
    }
  }

  private static class statfsTupleScheme extends TupleScheme<statfs> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, statfs struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetFrom()) {
        optionals.set(0);
      }
      if (struct.isSetTo()) {
        optionals.set(1);
      }
      if (struct.isSetIncreate()) {
        optionals.set(2);
      }
      if (struct.isSetClose()) {
        optionals.set(3);
      }
      if (struct.isSetReplicated()) {
        optionals.set(4);
      }
      if (struct.isSetRm_logical()) {
        optionals.set(5);
      }
      if (struct.isSetRm_physical()) {
        optionals.set(6);
      }
      if (struct.isSetUnderrep()) {
        optionals.set(7);
      }
      if (struct.isSetOverrep()) {
        optionals.set(8);
      }
      if (struct.isSetLinger()) {
        optionals.set(9);
      }
      if (struct.isSetSuspect()) {
        optionals.set(10);
      }
      if (struct.isSetInc_ons()) {
        optionals.set(11);
      }
      if (struct.isSetInc_ons2()) {
        optionals.set(12);
      }
      if (struct.isSetCls_offs()) {
        optionals.set(13);
      }
      if (struct.isSetIncs()) {
        optionals.set(14);
      }
      if (struct.isSetClos()) {
        optionals.set(15);
      }
      oprot.writeBitSet(optionals, 16);
      if (struct.isSetFrom()) {
        oprot.writeI64(struct.from);
      }
      if (struct.isSetTo()) {
        oprot.writeI64(struct.to);
      }
      if (struct.isSetIncreate()) {
        oprot.writeI64(struct.increate);
      }
      if (struct.isSetClose()) {
        oprot.writeI64(struct.close);
      }
      if (struct.isSetReplicated()) {
        oprot.writeI64(struct.replicated);
      }
      if (struct.isSetRm_logical()) {
        oprot.writeI64(struct.rm_logical);
      }
      if (struct.isSetRm_physical()) {
        oprot.writeI64(struct.rm_physical);
      }
      if (struct.isSetUnderrep()) {
        oprot.writeI64(struct.underrep);
      }
      if (struct.isSetOverrep()) {
        oprot.writeI64(struct.overrep);
      }
      if (struct.isSetLinger()) {
        oprot.writeI64(struct.linger);
      }
      if (struct.isSetSuspect()) {
        oprot.writeI64(struct.suspect);
      }
      if (struct.isSetInc_ons()) {
        oprot.writeI64(struct.inc_ons);
      }
      if (struct.isSetInc_ons2()) {
        oprot.writeI64(struct.inc_ons2);
      }
      if (struct.isSetCls_offs()) {
        oprot.writeI64(struct.cls_offs);
      }
      if (struct.isSetIncs()) {
        {
          oprot.writeI32(struct.incs.size());
          for (long _iter86 : struct.incs)
          {
            oprot.writeI64(_iter86);
          }
        }
      }
      if (struct.isSetClos()) {
        {
          oprot.writeI32(struct.clos.size());
          for (long _iter87 : struct.clos)
          {
            oprot.writeI64(_iter87);
          }
        }
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, statfs struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(16);
      if (incoming.get(0)) {
        struct.from = iprot.readI64();
        struct.setFromIsSet(true);
      }
      if (incoming.get(1)) {
        struct.to = iprot.readI64();
        struct.setToIsSet(true);
      }
      if (incoming.get(2)) {
        struct.increate = iprot.readI64();
        struct.setIncreateIsSet(true);
      }
      if (incoming.get(3)) {
        struct.close = iprot.readI64();
        struct.setCloseIsSet(true);
      }
      if (incoming.get(4)) {
        struct.replicated = iprot.readI64();
        struct.setReplicatedIsSet(true);
      }
      if (incoming.get(5)) {
        struct.rm_logical = iprot.readI64();
        struct.setRm_logicalIsSet(true);
      }
      if (incoming.get(6)) {
        struct.rm_physical = iprot.readI64();
        struct.setRm_physicalIsSet(true);
      }
      if (incoming.get(7)) {
        struct.underrep = iprot.readI64();
        struct.setUnderrepIsSet(true);
      }
      if (incoming.get(8)) {
        struct.overrep = iprot.readI64();
        struct.setOverrepIsSet(true);
      }
      if (incoming.get(9)) {
        struct.linger = iprot.readI64();
        struct.setLingerIsSet(true);
      }
      if (incoming.get(10)) {
        struct.suspect = iprot.readI64();
        struct.setSuspectIsSet(true);
      }
      if (incoming.get(11)) {
        struct.inc_ons = iprot.readI64();
        struct.setInc_onsIsSet(true);
      }
      if (incoming.get(12)) {
        struct.inc_ons2 = iprot.readI64();
        struct.setInc_ons2IsSet(true);
      }
      if (incoming.get(13)) {
        struct.cls_offs = iprot.readI64();
        struct.setCls_offsIsSet(true);
      }
      if (incoming.get(14)) {
        {
          org.apache.thrift.protocol.TList _list88 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I64, iprot.readI32());
          struct.incs = new ArrayList<Long>(_list88.size);
          for (int _i89 = 0; _i89 < _list88.size; ++_i89)
          {
            long _elem90; // required
            _elem90 = iprot.readI64();
            struct.incs.add(_elem90);
          }
        }
        struct.setIncsIsSet(true);
      }
      if (incoming.get(15)) {
        {
          org.apache.thrift.protocol.TList _list91 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I64, iprot.readI32());
          struct.clos = new ArrayList<Long>(_list91.size);
          for (int _i92 = 0; _i92 < _list91.size; ++_i92)
          {
            long _elem93; // required
            _elem93 = iprot.readI64();
            struct.clos.add(_elem93);
          }
        }
        struct.setClosIsSet(true);
      }
    }
  }

}

