<?php
namespace metastore;
/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Exception\TApplicationException;


interface ThriftHiveMetastoreIf extends \FacebookServiceIf {
  public function create_attribution(\metastore\Database $db);
  public function get_attribution($name);
  public function drop_attribution($name, $deleteData, $cascade);
  public function update_attribution(\metastore\Database $db);
  public function get_all_attributions();
  public function get_local_attribution();
  public function get_lucene_index_names($db_name, $tbl_name, $max_indexes);
  public function get_all_busi_type_cols();
  public function get_all_busi_type_datacenters();
  public function append_busi_type_datacenter(\metastore\BusiTypeDatacenter $busiTypeDatacenter);
  public function add_datawarehouse_sql($dwNum, $sql);
  public function showBusitypes();
  public function createBusitype(\metastore\Busitype $busitype);
  public function add_partition_files(\metastore\Partition $part, $files);
  public function drop_partition_files(\metastore\Partition $part, $files);
  public function add_subpartition_files(\metastore\Subpartition $subpart, $files);
  public function drop_subpartition_files(\metastore\Subpartition $subpart, $files);
  public function add_partition_index(\metastore\Index $index, \metastore\Partition $part);
  public function drop_partition_index(\metastore\Index $index, \metastore\Partition $part);
  public function add_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part);
  public function drop_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part);
  public function add_subpartition($dbname, $tbl_name, $part_vals, \metastore\Subpartition $sub_part);
  public function get_subpartitions($dbname, $tbl_name, \metastore\Partition $part);
  public function add_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file, $originfid);
  public function get_partition_index_files(\metastore\Index $index, \metastore\Partition $part);
  public function drop_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file);
  public function add_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file, $originfid);
  public function get_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart);
  public function drop_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file);
  public function addGeoLocation(\metastore\GeoLocation $gl);
  public function modifyGeoLocation(\metastore\GeoLocation $gl);
  public function deleteGeoLocation(\metastore\GeoLocation $gl);
  public function listGeoLocation();
  public function addEquipRoom(\metastore\EquipRoom $er);
  public function modifyEquipRoom(\metastore\EquipRoom $er);
  public function deleteEquipRoom(\metastore\EquipRoom $er);
  public function listEquipRoom();
  public function getGeoLocationByName($geoLocName);
  public function getGeoLocationByNames($geoLocNames);
  public function addNodeAssignment($nodeName, $dbName);
  public function deleteNodeAssignment($nodeName, $dbName);
  public function listNodes();
  public function addUserAssignment($roleName, $dbName);
  public function deleteUserAssignment($roleName, $dbName);
  public function listUsers();
  public function addRoleAssignment($userName, $dbName);
  public function deleteRoleAssignment($userName, $dbName);
  public function listRoles();
  public function addNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName);
  public function deleteNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName);
  public function pingPong($str);
  public function create_database(\metastore\Database $database);
  public function get_database($name);
  public function drop_database($name, $deleteData, $cascade);
  public function get_databases($pattern);
  public function get_all_databases();
  public function alter_database($dbname, \metastore\Database $db);
  public function get_type($name);
  public function create_type(\metastore\Type $type);
  public function drop_type($type);
  public function get_type_all($name);
  public function get_fields($db_name, $table_name);
  public function get_schema($db_name, $table_name);
  public function create_table(\metastore\Table $tbl);
  public function create_table_by_user(\metastore\Table $tbl, \metastore\User $user);
  public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context);
  public function drop_table($dbname, $name, $deleteData);
  public function get_tables($db_name, $pattern);
  public function get_all_tables($db_name);
  public function get_table($dbname, $tbl_name);
  public function get_table_objects_by_name($dbname, $tbl_names);
  public function get_table_names_by_filter($dbname, $filter, $max_tables);
  public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl);
  public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context);
  public function add_partition(\metastore\Partition $new_part);
  public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context);
  public function add_partitions($new_parts);
  public function append_partition($db_name, $tbl_name, $part_vals);
  public function append_partition_by_name($db_name, $tbl_name, $part_name);
  public function drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
  public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
  public function get_partition($db_name, $tbl_name, $part_vals);
  public function get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
  public function get_partition_by_name($db_name, $tbl_name, $part_name);
  public function get_partitions($db_name, $tbl_name, $max_parts);
  public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
  public function get_partition_names($db_name, $tbl_name, $max_parts);
  public function get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
  public function get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
  public function get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
  public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
  public function get_partitions_by_names($db_name, $tbl_name, $names);
  public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part);
  public function alter_partitions($db_name, $tbl_name, $new_parts);
  public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context);
  public function rename_partition($db_name, $tbl_name, $part_vals, \metastore\Partition $new_part);
  public function get_config_value($name, $defaultValue);
  public function partition_name_to_vals($part_name);
  public function partition_name_to_spec($part_name);
  public function markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
  public function isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
  public function add_index(\metastore\Index $new_index, \metastore\Table $index_table);
  public function alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx);
  public function drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
  public function get_index_by_name($db_name, $tbl_name, $index_name);
  public function get_indexes($db_name, $tbl_name, $max_indexes);
  public function get_index_names($db_name, $tbl_name, $max_indexes);
  public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj);
  public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj);
  public function get_table_column_statistics($db_name, $tbl_name, $col_name);
  public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
  public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
  public function delete_table_column_statistics($db_name, $tbl_name, $col_name);
  public function create_user(\metastore\User $user);
  public function drop_user($user_name);
  public function modify_user(\metastore\User $user);
  public function list_users_names();
  public function list_users(\metastore\Database $db);
  public function authentication($user_name, $passwd);
  public function user_authority_check(\metastore\User $user, \metastore\Table $tbl, $ops);
  public function create_role(\metastore\Role $role);
  public function drop_role($role_name);
  public function get_role_names();
  public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
  public function revoke_role($role_name, $principal_name, $principal_type);
  public function list_roles($principal_name, $principal_type);
  public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, $group_names);
  public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject);
  public function grant_privileges(\metastore\PrivilegeBag $privileges);
  public function revoke_privileges(\metastore\PrivilegeBag $privileges);
  public function set_ugi($user_name, $group_names);
  public function get_delegation_token($token_owner, $renewer_kerberos_principal_name);
  public function renew_delegation_token($token_str_form);
  public function cancel_delegation_token($token_str_form);
  public function create_file($node_name, $repnr, $db_name, $table_name, $values);
  public function create_file_by_policy(\metastore\CreatePolicy $policy, $repnr, $db_name, $table_name, $values);
  public function close_file(\metastore\SFile $file);
  public function online_filelocation(\metastore\SFile $file);
  public function toggle_safemode();
  public function get_file_by_id($fid);
  public function get_file_by_name($node, $devid, $location);
  public function rm_file_logical(\metastore\SFile $file);
  public function restore_file(\metastore\SFile $file);
  public function rm_file_physical(\metastore\SFile $file);
  public function get_node($node_name);
  public function add_node($node_name, $ipl);
  public function del_node($node_name);
  public function create_device($devid, $prop, $node_name);
  public function get_device($devid);
  public function del_device($devid);
  public function modify_device(\metastore\Device $dev, \metastore\Node $node);
  public function alter_node($node_name, $ipl, $status);
  public function find_best_nodes($nr);
  public function find_best_nodes_in_groups($dbName, $tableName, $nr, $policy);
  public function get_all_nodes();
  public function getDMStatus();
  public function getNodeInfo();
  public function migrate_in(\metastore\Table $tbl, $files, $idxs, $from_db, $to_devid, $fileMap);
  public function migrate_stage1($dbName, $tableName, $files, $to_db);
  public function migrate_stage2($dbName, $tableName, $files, $from_db, $to_db, $to_devid);
  public function migrate2_in(\metastore\Table $tbl, $parts, $idxs, $from_db, $to_nas_devid, $fileMap);
  public function migrate2_stage1($dbName, $tableName, $partNames, $to_db);
  public function migrate2_stage2($dbName, $tableName, $partNames, $from_db, $to_db, $to_nas_devid);
  public function getMP($node_name, $devid);
  public function getSessionId();
  public function createSchema(\metastore\GlobalSchema $schema);
  public function modifySchema($schemaName, \metastore\GlobalSchema $schema);
  public function deleteSchema($schemaName);
  public function listSchemas();
  public function getSchemaByName($schemaName);
  public function getTableNodeGroups($dbName, $tabName);
  public function getTableNodeFiles($dbName, $tabName, $nodeName);
  public function listTableFiles($dbName, $tabName, $from, $to);
  public function listFilesByDigest($digest);
  public function filterTableFiles($dbName, $tabName, $values);
  public function truncTableFiles($dbName, $tabName);
  public function addNodeGroup(\metastore\NodeGroup $ng);
  public function modifyNodeGroup($schemaName, \metastore\NodeGroup $ng);
  public function deleteNodeGroup(\metastore\NodeGroup $ng);
  public function listNodeGroups();
  public function listDBNodeGroups($dbName);
  public function listNodeGroupByNames($ngNames);
  public function addTableNodeDist($db, $tab, $ng);
  public function deleteTableNodeDist($db, $tab, $ng);
  public function listTableNodeDists($dbName, $tabName);
  public function assiginSchematoDB($dbName, $schemaName, $fileSplitKeys, $part_keys, $ngs);
}

class ThriftHiveMetastoreClient extends \FacebookServiceClient implements \metastore\ThriftHiveMetastoreIf {
  public function __construct($input, $output=null) {
    parent::__construct($input, $output);
  }

  public function create_attribution(\metastore\Database $db)
  {
    $this->send_create_attribution($db);
    $this->recv_create_attribution();
  }

  public function send_create_attribution(\metastore\Database $db)
  {
    $args = new \metastore\ThriftHiveMetastore_create_attribution_args();
    $args->db = $db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_attribution', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_attribution', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_attribution()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_attribution_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_attribution_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_attribution($name)
  {
    $this->send_get_attribution($name);
    return $this->recv_get_attribution();
  }

  public function send_get_attribution($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_attribution_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_attribution', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_attribution', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_attribution()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_attribution_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_attribution_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_attribution failed: unknown result");
  }

  public function drop_attribution($name, $deleteData, $cascade)
  {
    $this->send_drop_attribution($name, $deleteData, $cascade);
    $this->recv_drop_attribution();
  }

  public function send_drop_attribution($name, $deleteData, $cascade)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_attribution_args();
    $args->name = $name;
    $args->deleteData = $deleteData;
    $args->cascade = $cascade;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_attribution', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_attribution', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_attribution()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_attribution_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_attribution_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function update_attribution(\metastore\Database $db)
  {
    $this->send_update_attribution($db);
    $this->recv_update_attribution();
  }

  public function send_update_attribution(\metastore\Database $db)
  {
    $args = new \metastore\ThriftHiveMetastore_update_attribution_args();
    $args->db = $db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_attribution', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_attribution', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_attribution()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_attribution_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_attribution_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_all_attributions()
  {
    $this->send_get_all_attributions();
    return $this->recv_get_all_attributions();
  }

  public function send_get_all_attributions()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_attributions_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_attributions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_attributions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_attributions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_attributions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_attributions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_attributions failed: unknown result");
  }

  public function get_local_attribution()
  {
    $this->send_get_local_attribution();
    return $this->recv_get_local_attribution();
  }

  public function send_get_local_attribution()
  {
    $args = new \metastore\ThriftHiveMetastore_get_local_attribution_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_local_attribution', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_local_attribution', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_local_attribution()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_local_attribution_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_local_attribution_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_local_attribution failed: unknown result");
  }

  public function get_lucene_index_names($db_name, $tbl_name, $max_indexes)
  {
    $this->send_get_lucene_index_names($db_name, $tbl_name, $max_indexes);
    return $this->recv_get_lucene_index_names();
  }

  public function send_get_lucene_index_names($db_name, $tbl_name, $max_indexes)
  {
    $args = new \metastore\ThriftHiveMetastore_get_lucene_index_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_indexes = $max_indexes;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_lucene_index_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_lucene_index_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_lucene_index_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_lucene_index_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_lucene_index_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_lucene_index_names failed: unknown result");
  }

  public function get_all_busi_type_cols()
  {
    $this->send_get_all_busi_type_cols();
    return $this->recv_get_all_busi_type_cols();
  }

  public function send_get_all_busi_type_cols()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_busi_type_cols_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_busi_type_cols', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_busi_type_cols', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_busi_type_cols()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_busi_type_cols_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_busi_type_cols_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_busi_type_cols failed: unknown result");
  }

  public function get_all_busi_type_datacenters()
  {
    $this->send_get_all_busi_type_datacenters();
    return $this->recv_get_all_busi_type_datacenters();
  }

  public function send_get_all_busi_type_datacenters()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_busi_type_datacenters_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_busi_type_datacenters', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_busi_type_datacenters', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_busi_type_datacenters()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_busi_type_datacenters_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_busi_type_datacenters_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_busi_type_datacenters failed: unknown result");
  }

  public function append_busi_type_datacenter(\metastore\BusiTypeDatacenter $busiTypeDatacenter)
  {
    $this->send_append_busi_type_datacenter($busiTypeDatacenter);
    $this->recv_append_busi_type_datacenter();
  }

  public function send_append_busi_type_datacenter(\metastore\BusiTypeDatacenter $busiTypeDatacenter)
  {
    $args = new \metastore\ThriftHiveMetastore_append_busi_type_datacenter_args();
    $args->busiTypeDatacenter = $busiTypeDatacenter;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_busi_type_datacenter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_busi_type_datacenter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_busi_type_datacenter()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_busi_type_datacenter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_busi_type_datacenter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_datawarehouse_sql($dwNum, $sql)
  {
    $this->send_add_datawarehouse_sql($dwNum, $sql);
    return $this->recv_add_datawarehouse_sql();
  }

  public function send_add_datawarehouse_sql($dwNum, $sql)
  {
    $args = new \metastore\ThriftHiveMetastore_add_datawarehouse_sql_args();
    $args->dwNum = $dwNum;
    $args->sql = $sql;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_datawarehouse_sql', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_datawarehouse_sql', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_datawarehouse_sql()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_datawarehouse_sql_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_datawarehouse_sql_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("add_datawarehouse_sql failed: unknown result");
  }

  public function showBusitypes()
  {
    $this->send_showBusitypes();
    return $this->recv_showBusitypes();
  }

  public function send_showBusitypes()
  {
    $args = new \metastore\ThriftHiveMetastore_showBusitypes_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'showBusitypes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('showBusitypes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_showBusitypes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_showBusitypes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_showBusitypes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("showBusitypes failed: unknown result");
  }

  public function createBusitype(\metastore\Busitype $busitype)
  {
    $this->send_createBusitype($busitype);
    return $this->recv_createBusitype();
  }

  public function send_createBusitype(\metastore\Busitype $busitype)
  {
    $args = new \metastore\ThriftHiveMetastore_createBusitype_args();
    $args->busitype = $busitype;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createBusitype', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createBusitype', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createBusitype()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_createBusitype_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_createBusitype_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("createBusitype failed: unknown result");
  }

  public function add_partition_files(\metastore\Partition $part, $files)
  {
    $this->send_add_partition_files($part, $files);
    return $this->recv_add_partition_files();
  }

  public function send_add_partition_files(\metastore\Partition $part, $files)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_files_args();
    $args->part = $part;
    $args->files = $files;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("add_partition_files failed: unknown result");
  }

  public function drop_partition_files(\metastore\Partition $part, $files)
  {
    $this->send_drop_partition_files($part, $files);
    return $this->recv_drop_partition_files();
  }

  public function send_drop_partition_files(\metastore\Partition $part, $files)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_files_args();
    $args->part = $part;
    $args->files = $files;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("drop_partition_files failed: unknown result");
  }

  public function add_subpartition_files(\metastore\Subpartition $subpart, $files)
  {
    $this->send_add_subpartition_files($subpart, $files);
    return $this->recv_add_subpartition_files();
  }

  public function send_add_subpartition_files(\metastore\Subpartition $subpart, $files)
  {
    $args = new \metastore\ThriftHiveMetastore_add_subpartition_files_args();
    $args->subpart = $subpart;
    $args->files = $files;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_subpartition_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_subpartition_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_subpartition_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_subpartition_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_subpartition_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("add_subpartition_files failed: unknown result");
  }

  public function drop_subpartition_files(\metastore\Subpartition $subpart, $files)
  {
    $this->send_drop_subpartition_files($subpart, $files);
    return $this->recv_drop_subpartition_files();
  }

  public function send_drop_subpartition_files(\metastore\Subpartition $subpart, $files)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_subpartition_files_args();
    $args->subpart = $subpart;
    $args->files = $files;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_subpartition_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_subpartition_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_subpartition_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_subpartition_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_subpartition_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("drop_subpartition_files failed: unknown result");
  }

  public function add_partition_index(\metastore\Index $index, \metastore\Partition $part)
  {
    $this->send_add_partition_index($index, $part);
    return $this->recv_add_partition_index();
  }

  public function send_add_partition_index(\metastore\Index $index, \metastore\Partition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_index_args();
    $args->index = $index;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("add_partition_index failed: unknown result");
  }

  public function drop_partition_index(\metastore\Index $index, \metastore\Partition $part)
  {
    $this->send_drop_partition_index($index, $part);
    return $this->recv_drop_partition_index();
  }

  public function send_drop_partition_index(\metastore\Index $index, \metastore\Partition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_index_args();
    $args->index = $index;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition_index failed: unknown result");
  }

  public function add_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part)
  {
    $this->send_add_subpartition_index($index, $part);
    return $this->recv_add_subpartition_index();
  }

  public function send_add_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_add_subpartition_index_args();
    $args->index = $index;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_subpartition_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_subpartition_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_subpartition_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_subpartition_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_subpartition_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("add_subpartition_index failed: unknown result");
  }

  public function drop_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part)
  {
    $this->send_drop_subpartition_index($index, $part);
    return $this->recv_drop_subpartition_index();
  }

  public function send_drop_subpartition_index(\metastore\Index $index, \metastore\Subpartition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_subpartition_index_args();
    $args->index = $index;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_subpartition_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_subpartition_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_subpartition_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_subpartition_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_subpartition_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_subpartition_index failed: unknown result");
  }

  public function add_subpartition($dbname, $tbl_name, $part_vals, \metastore\Subpartition $sub_part)
  {
    $this->send_add_subpartition($dbname, $tbl_name, $part_vals, $sub_part);
    return $this->recv_add_subpartition();
  }

  public function send_add_subpartition($dbname, $tbl_name, $part_vals, \metastore\Subpartition $sub_part)
  {
    $args = new \metastore\ThriftHiveMetastore_add_subpartition_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->sub_part = $sub_part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_subpartition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_subpartition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_subpartition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_subpartition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_subpartition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("add_subpartition failed: unknown result");
  }

  public function get_subpartitions($dbname, $tbl_name, \metastore\Partition $part)
  {
    $this->send_get_subpartitions($dbname, $tbl_name, $part);
    return $this->recv_get_subpartitions();
  }

  public function send_get_subpartitions($dbname, $tbl_name, \metastore\Partition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_get_subpartitions_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_subpartitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_subpartitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_subpartitions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_subpartitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_subpartitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("get_subpartitions failed: unknown result");
  }

  public function add_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file, $originfid)
  {
    $this->send_add_partition_index_files($index, $part, $file, $originfid);
    return $this->recv_add_partition_index_files();
  }

  public function send_add_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file, $originfid)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_index_files_args();
    $args->index = $index;
    $args->part = $part;
    $args->file = $file;
    $args->originfid = $originfid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("add_partition_index_files failed: unknown result");
  }

  public function get_partition_index_files(\metastore\Index $index, \metastore\Partition $part)
  {
    $this->send_get_partition_index_files($index, $part);
    return $this->recv_get_partition_index_files();
  }

  public function send_get_partition_index_files(\metastore\Index $index, \metastore\Partition $part)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_index_files_args();
    $args->index = $index;
    $args->part = $part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_partition_index_files failed: unknown result");
  }

  public function drop_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file)
  {
    $this->send_drop_partition_index_files($index, $part, $file);
    return $this->recv_drop_partition_index_files();
  }

  public function send_drop_partition_index_files(\metastore\Index $index, \metastore\Partition $part, $file)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_index_files_args();
    $args->index = $index;
    $args->part = $part;
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("drop_partition_index_files failed: unknown result");
  }

  public function add_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file, $originfid)
  {
    $this->send_add_subpartition_index_files($index, $subpart, $file, $originfid);
    return $this->recv_add_subpartition_index_files();
  }

  public function send_add_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file, $originfid)
  {
    $args = new \metastore\ThriftHiveMetastore_add_subpartition_index_files_args();
    $args->index = $index;
    $args->subpart = $subpart;
    $args->file = $file;
    $args->originfid = $originfid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_subpartition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_subpartition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_subpartition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_subpartition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_subpartition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("add_subpartition_index_files failed: unknown result");
  }

  public function get_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart)
  {
    $this->send_get_subpartition_index_files($index, $subpart);
    return $this->recv_get_subpartition_index_files();
  }

  public function send_get_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart)
  {
    $args = new \metastore\ThriftHiveMetastore_get_subpartition_index_files_args();
    $args->index = $index;
    $args->subpart = $subpart;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_subpartition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_subpartition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_subpartition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_subpartition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_subpartition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_subpartition_index_files failed: unknown result");
  }

  public function drop_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file)
  {
    $this->send_drop_subpartition_index_files($index, $subpart, $file);
    return $this->recv_drop_subpartition_index_files();
  }

  public function send_drop_subpartition_index_files(\metastore\Index $index, \metastore\Subpartition $subpart, $file)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_subpartition_index_files_args();
    $args->index = $index;
    $args->subpart = $subpart;
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_subpartition_index_files', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_subpartition_index_files', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_subpartition_index_files()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_subpartition_index_files_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_subpartition_index_files_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("drop_subpartition_index_files failed: unknown result");
  }

  public function addGeoLocation(\metastore\GeoLocation $gl)
  {
    $this->send_addGeoLocation($gl);
    return $this->recv_addGeoLocation();
  }

  public function send_addGeoLocation(\metastore\GeoLocation $gl)
  {
    $args = new \metastore\ThriftHiveMetastore_addGeoLocation_args();
    $args->gl = $gl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addGeoLocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addGeoLocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addGeoLocation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addGeoLocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addGeoLocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("addGeoLocation failed: unknown result");
  }

  public function modifyGeoLocation(\metastore\GeoLocation $gl)
  {
    $this->send_modifyGeoLocation($gl);
    return $this->recv_modifyGeoLocation();
  }

  public function send_modifyGeoLocation(\metastore\GeoLocation $gl)
  {
    $args = new \metastore\ThriftHiveMetastore_modifyGeoLocation_args();
    $args->gl = $gl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modifyGeoLocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modifyGeoLocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modifyGeoLocation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modifyGeoLocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modifyGeoLocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("modifyGeoLocation failed: unknown result");
  }

  public function deleteGeoLocation(\metastore\GeoLocation $gl)
  {
    $this->send_deleteGeoLocation($gl);
    return $this->recv_deleteGeoLocation();
  }

  public function send_deleteGeoLocation(\metastore\GeoLocation $gl)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteGeoLocation_args();
    $args->gl = $gl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteGeoLocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteGeoLocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteGeoLocation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteGeoLocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteGeoLocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteGeoLocation failed: unknown result");
  }

  public function listGeoLocation()
  {
    $this->send_listGeoLocation();
    return $this->recv_listGeoLocation();
  }

  public function send_listGeoLocation()
  {
    $args = new \metastore\ThriftHiveMetastore_listGeoLocation_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listGeoLocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listGeoLocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listGeoLocation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listGeoLocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listGeoLocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listGeoLocation failed: unknown result");
  }

  public function addEquipRoom(\metastore\EquipRoom $er)
  {
    $this->send_addEquipRoom($er);
    return $this->recv_addEquipRoom();
  }

  public function send_addEquipRoom(\metastore\EquipRoom $er)
  {
    $args = new \metastore\ThriftHiveMetastore_addEquipRoom_args();
    $args->er = $er;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addEquipRoom', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addEquipRoom', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addEquipRoom()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addEquipRoom_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addEquipRoom_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("addEquipRoom failed: unknown result");
  }

  public function modifyEquipRoom(\metastore\EquipRoom $er)
  {
    $this->send_modifyEquipRoom($er);
    return $this->recv_modifyEquipRoom();
  }

  public function send_modifyEquipRoom(\metastore\EquipRoom $er)
  {
    $args = new \metastore\ThriftHiveMetastore_modifyEquipRoom_args();
    $args->er = $er;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modifyEquipRoom', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modifyEquipRoom', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modifyEquipRoom()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modifyEquipRoom_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modifyEquipRoom_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("modifyEquipRoom failed: unknown result");
  }

  public function deleteEquipRoom(\metastore\EquipRoom $er)
  {
    $this->send_deleteEquipRoom($er);
    return $this->recv_deleteEquipRoom();
  }

  public function send_deleteEquipRoom(\metastore\EquipRoom $er)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteEquipRoom_args();
    $args->er = $er;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteEquipRoom', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteEquipRoom', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteEquipRoom()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteEquipRoom_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteEquipRoom_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteEquipRoom failed: unknown result");
  }

  public function listEquipRoom()
  {
    $this->send_listEquipRoom();
    return $this->recv_listEquipRoom();
  }

  public function send_listEquipRoom()
  {
    $args = new \metastore\ThriftHiveMetastore_listEquipRoom_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listEquipRoom', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listEquipRoom', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listEquipRoom()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listEquipRoom_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listEquipRoom_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listEquipRoom failed: unknown result");
  }

  public function getGeoLocationByName($geoLocName)
  {
    $this->send_getGeoLocationByName($geoLocName);
    return $this->recv_getGeoLocationByName();
  }

  public function send_getGeoLocationByName($geoLocName)
  {
    $args = new \metastore\ThriftHiveMetastore_getGeoLocationByName_args();
    $args->geoLocName = $geoLocName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getGeoLocationByName', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getGeoLocationByName', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getGeoLocationByName()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getGeoLocationByName_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getGeoLocationByName_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("getGeoLocationByName failed: unknown result");
  }

  public function getGeoLocationByNames($geoLocNames)
  {
    $this->send_getGeoLocationByNames($geoLocNames);
    return $this->recv_getGeoLocationByNames();
  }

  public function send_getGeoLocationByNames($geoLocNames)
  {
    $args = new \metastore\ThriftHiveMetastore_getGeoLocationByNames_args();
    $args->geoLocNames = $geoLocNames;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getGeoLocationByNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getGeoLocationByNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getGeoLocationByNames()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getGeoLocationByNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getGeoLocationByNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getGeoLocationByNames failed: unknown result");
  }

  public function addNodeAssignment($nodeName, $dbName)
  {
    $this->send_addNodeAssignment($nodeName, $dbName);
    return $this->recv_addNodeAssignment();
  }

  public function send_addNodeAssignment($nodeName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_addNodeAssignment_args();
    $args->nodeName = $nodeName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addNodeAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addNodeAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addNodeAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addNodeAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addNodeAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("addNodeAssignment failed: unknown result");
  }

  public function deleteNodeAssignment($nodeName, $dbName)
  {
    $this->send_deleteNodeAssignment($nodeName, $dbName);
    return $this->recv_deleteNodeAssignment();
  }

  public function send_deleteNodeAssignment($nodeName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteNodeAssignment_args();
    $args->nodeName = $nodeName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteNodeAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteNodeAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteNodeAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteNodeAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteNodeAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("deleteNodeAssignment failed: unknown result");
  }

  public function listNodes()
  {
    $this->send_listNodes();
    return $this->recv_listNodes();
  }

  public function send_listNodes()
  {
    $args = new \metastore\ThriftHiveMetastore_listNodes_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listNodes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listNodes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listNodes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listNodes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listNodes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listNodes failed: unknown result");
  }

  public function addUserAssignment($roleName, $dbName)
  {
    $this->send_addUserAssignment($roleName, $dbName);
    return $this->recv_addUserAssignment();
  }

  public function send_addUserAssignment($roleName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_addUserAssignment_args();
    $args->roleName = $roleName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addUserAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addUserAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addUserAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addUserAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addUserAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("addUserAssignment failed: unknown result");
  }

  public function deleteUserAssignment($roleName, $dbName)
  {
    $this->send_deleteUserAssignment($roleName, $dbName);
    return $this->recv_deleteUserAssignment();
  }

  public function send_deleteUserAssignment($roleName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteUserAssignment_args();
    $args->roleName = $roleName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteUserAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteUserAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteUserAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteUserAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteUserAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("deleteUserAssignment failed: unknown result");
  }

  public function listUsers()
  {
    $this->send_listUsers();
    return $this->recv_listUsers();
  }

  public function send_listUsers()
  {
    $args = new \metastore\ThriftHiveMetastore_listUsers_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listUsers', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listUsers', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listUsers()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listUsers_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listUsers_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listUsers failed: unknown result");
  }

  public function addRoleAssignment($userName, $dbName)
  {
    $this->send_addRoleAssignment($userName, $dbName);
    return $this->recv_addRoleAssignment();
  }

  public function send_addRoleAssignment($userName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_addRoleAssignment_args();
    $args->userName = $userName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addRoleAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addRoleAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addRoleAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addRoleAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addRoleAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("addRoleAssignment failed: unknown result");
  }

  public function deleteRoleAssignment($userName, $dbName)
  {
    $this->send_deleteRoleAssignment($userName, $dbName);
    return $this->recv_deleteRoleAssignment();
  }

  public function send_deleteRoleAssignment($userName, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteRoleAssignment_args();
    $args->userName = $userName;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteRoleAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteRoleAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteRoleAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteRoleAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteRoleAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("deleteRoleAssignment failed: unknown result");
  }

  public function listRoles()
  {
    $this->send_listRoles();
    return $this->recv_listRoles();
  }

  public function send_listRoles()
  {
    $args = new \metastore\ThriftHiveMetastore_listRoles_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listRoles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listRoles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listRoles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listRoles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listRoles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listRoles failed: unknown result");
  }

  public function addNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName)
  {
    $this->send_addNodeGroupAssignment($ng, $dbName);
    return $this->recv_addNodeGroupAssignment();
  }

  public function send_addNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_addNodeGroupAssignment_args();
    $args->ng = $ng;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addNodeGroupAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addNodeGroupAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addNodeGroupAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addNodeGroupAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addNodeGroupAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("addNodeGroupAssignment failed: unknown result");
  }

  public function deleteNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName)
  {
    $this->send_deleteNodeGroupAssignment($ng, $dbName);
    return $this->recv_deleteNodeGroupAssignment();
  }

  public function send_deleteNodeGroupAssignment(\metastore\NodeGroup $ng, $dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteNodeGroupAssignment_args();
    $args->ng = $ng;
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteNodeGroupAssignment', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteNodeGroupAssignment', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteNodeGroupAssignment()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteNodeGroupAssignment_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteNodeGroupAssignment_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteNodeGroupAssignment failed: unknown result");
  }

  public function pingPong($str)
  {
    $this->send_pingPong($str);
    return $this->recv_pingPong();
  }

  public function send_pingPong($str)
  {
    $args = new \metastore\ThriftHiveMetastore_pingPong_args();
    $args->str = $str;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'pingPong', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('pingPong', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_pingPong()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_pingPong_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_pingPong_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("pingPong failed: unknown result");
  }

  public function create_database(\metastore\Database $database)
  {
    $this->send_create_database($database);
    $this->recv_create_database();
  }

  public function send_create_database(\metastore\Database $database)
  {
    $args = new \metastore\ThriftHiveMetastore_create_database_args();
    $args->database = $database;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_database()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_database($name)
  {
    $this->send_get_database($name);
    return $this->recv_get_database();
  }

  public function send_get_database($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_database_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_database()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_database failed: unknown result");
  }

  public function drop_database($name, $deleteData, $cascade)
  {
    $this->send_drop_database($name, $deleteData, $cascade);
    $this->recv_drop_database();
  }

  public function send_drop_database($name, $deleteData, $cascade)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_database_args();
    $args->name = $name;
    $args->deleteData = $deleteData;
    $args->cascade = $cascade;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_database()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_databases($pattern)
  {
    $this->send_get_databases($pattern);
    return $this->recv_get_databases();
  }

  public function send_get_databases($pattern)
  {
    $args = new \metastore\ThriftHiveMetastore_get_databases_args();
    $args->pattern = $pattern;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_databases', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_databases', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_databases()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_databases_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_databases_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_databases failed: unknown result");
  }

  public function get_all_databases()
  {
    $this->send_get_all_databases();
    return $this->recv_get_all_databases();
  }

  public function send_get_all_databases()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_databases_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_databases', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_databases', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_databases()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_databases_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_databases_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_databases failed: unknown result");
  }

  public function alter_database($dbname, \metastore\Database $db)
  {
    $this->send_alter_database($dbname, $db);
    $this->recv_alter_database();
  }

  public function send_alter_database($dbname, \metastore\Database $db)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_database_args();
    $args->dbname = $dbname;
    $args->db = $db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_database', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_database', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_database()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_database_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_database_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function get_type($name)
  {
    $this->send_get_type($name);
    return $this->recv_get_type();
  }

  public function send_get_type($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_type_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_type()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_type failed: unknown result");
  }

  public function create_type(\metastore\Type $type)
  {
    $this->send_create_type($type);
    return $this->recv_create_type();
  }

  public function send_create_type(\metastore\Type $type)
  {
    $args = new \metastore\ThriftHiveMetastore_create_type_args();
    $args->type = $type;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_type()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("create_type failed: unknown result");
  }

  public function drop_type($type)
  {
    $this->send_drop_type($type);
    return $this->recv_drop_type();
  }

  public function send_drop_type($type)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_type_args();
    $args->type = $type;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_type', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_type', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_type()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_type_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_type_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_type failed: unknown result");
  }

  public function get_type_all($name)
  {
    $this->send_get_type_all($name);
    return $this->recv_get_type_all();
  }

  public function send_get_type_all($name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_type_all_args();
    $args->name = $name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_type_all', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_type_all', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_type_all()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_type_all_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_type_all_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_type_all failed: unknown result");
  }

  public function get_fields($db_name, $table_name)
  {
    $this->send_get_fields($db_name, $table_name);
    return $this->recv_get_fields();
  }

  public function send_get_fields($db_name, $table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_fields_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_fields', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_fields', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_fields()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_fields_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_fields_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_fields failed: unknown result");
  }

  public function get_schema($db_name, $table_name)
  {
    $this->send_get_schema($db_name, $table_name);
    return $this->recv_get_schema();
  }

  public function send_get_schema($db_name, $table_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_schema_args();
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_schema', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_schema', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_schema()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_schema_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_schema_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_schema failed: unknown result");
  }

  public function create_table(\metastore\Table $tbl)
  {
    $this->send_create_table($tbl);
    $this->recv_create_table();
  }

  public function send_create_table(\metastore\Table $tbl)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_args();
    $args->tbl = $tbl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function create_table_by_user(\metastore\Table $tbl, \metastore\User $user)
  {
    $this->send_create_table_by_user($tbl, $user);
    $this->recv_create_table_by_user();
  }

  public function send_create_table_by_user(\metastore\Table $tbl, \metastore\User $user)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_by_user_args();
    $args->tbl = $tbl;
    $args->user = $user;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table_by_user', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table_by_user', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table_by_user()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_by_user_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_by_user_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_create_table_with_environment_context($tbl, $environment_context);
    $this->recv_create_table_with_environment_context();
  }

  public function send_create_table_with_environment_context(\metastore\Table $tbl, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_args();
    $args->tbl = $tbl;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_table_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_table_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_table_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_table_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_table_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    return;
  }

  public function drop_table($dbname, $name, $deleteData)
  {
    $this->send_drop_table($dbname, $name, $deleteData);
    $this->recv_drop_table();
  }

  public function send_drop_table($dbname, $name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_table_args();
    $args->dbname = $dbname;
    $args->name = $name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_table()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    return;
  }

  public function get_tables($db_name, $pattern)
  {
    $this->send_get_tables($db_name, $pattern);
    return $this->recv_get_tables();
  }

  public function send_get_tables($db_name, $pattern)
  {
    $args = new \metastore\ThriftHiveMetastore_get_tables_args();
    $args->db_name = $db_name;
    $args->pattern = $pattern;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_tables', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_tables', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_tables()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_tables_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_tables_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_tables failed: unknown result");
  }

  public function get_all_tables($db_name)
  {
    $this->send_get_all_tables($db_name);
    return $this->recv_get_all_tables();
  }

  public function send_get_all_tables($db_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_tables_args();
    $args->db_name = $db_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_tables', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_tables', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_tables()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_tables_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_tables_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_tables failed: unknown result");
  }

  public function get_table($dbname, $tbl_name)
  {
    $this->send_get_table($dbname, $tbl_name);
    return $this->recv_get_table();
  }

  public function send_get_table($dbname, $tbl_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_table failed: unknown result");
  }

  public function get_table_objects_by_name($dbname, $tbl_names)
  {
    $this->send_get_table_objects_by_name($dbname, $tbl_names);
    return $this->recv_get_table_objects_by_name();
  }

  public function send_get_table_objects_by_name($dbname, $tbl_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_args();
    $args->dbname = $dbname;
    $args->tbl_names = $tbl_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_objects_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_objects_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_objects_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_objects_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_objects_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_table_objects_by_name failed: unknown result");
  }

  public function get_table_names_by_filter($dbname, $filter, $max_tables)
  {
    $this->send_get_table_names_by_filter($dbname, $filter, $max_tables);
    return $this->recv_get_table_names_by_filter();
  }

  public function send_get_table_names_by_filter($dbname, $filter, $max_tables)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_args();
    $args->dbname = $dbname;
    $args->filter = $filter;
    $args->max_tables = $max_tables;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_names_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_names_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_names_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_names_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_names_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("get_table_names_by_filter failed: unknown result");
  }

  public function alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
  {
    $this->send_alter_table($dbname, $tbl_name, $new_tbl);
    $this->recv_alter_table();
  }

  public function send_alter_table($dbname, $tbl_name, \metastore\Table $new_tbl)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_table_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->new_tbl = $new_tbl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_table', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_table', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_table()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_table_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_table_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_alter_table_with_environment_context($dbname, $tbl_name, $new_tbl, $environment_context);
    $this->recv_alter_table_with_environment_context();
  }

  public function send_alter_table_with_environment_context($dbname, $tbl_name, \metastore\Table $new_tbl, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_args();
    $args->dbname = $dbname;
    $args->tbl_name = $tbl_name;
    $args->new_tbl = $new_tbl;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_table_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_table_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_table_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_table_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_table_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function add_partition(\metastore\Partition $new_part)
  {
    $this->send_add_partition($new_part);
    return $this->recv_add_partition();
  }

  public function send_add_partition(\metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_args();
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partition failed: unknown result");
  }

  public function add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_add_partition_with_environment_context($new_part, $environment_context);
    return $this->recv_add_partition_with_environment_context();
  }

  public function send_add_partition_with_environment_context(\metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_args();
    $args->new_part = $new_part;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partition_with_environment_context failed: unknown result");
  }

  public function add_partitions($new_parts)
  {
    $this->send_add_partitions($new_parts);
    return $this->recv_add_partitions();
  }

  public function send_add_partitions($new_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_add_partitions_args();
    $args->new_parts = $new_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_partitions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_partitions failed: unknown result");
  }

  public function append_partition($db_name, $tbl_name, $part_vals)
  {
    $this->send_append_partition($db_name, $tbl_name, $part_vals);
    return $this->recv_append_partition();
  }

  public function send_append_partition($db_name, $tbl_name, $part_vals)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition failed: unknown result");
  }

  public function append_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $this->send_append_partition_by_name($db_name, $tbl_name, $part_name);
    return $this->recv_append_partition_by_name();
  }

  public function send_append_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_append_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'append_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_append_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_append_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_append_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("append_partition_by_name failed: unknown result");
  }

  public function drop_partition($db_name, $tbl_name, $part_vals, $deleteData)
  {
    $this->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
    return $this->recv_drop_partition();
  }

  public function send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition failed: unknown result");
  }

  public function drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
  {
    $this->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
    return $this->recv_drop_partition_by_name();
  }

  public function send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_partition_by_name failed: unknown result");
  }

  public function get_partition($db_name, $tbl_name, $part_vals)
  {
    $this->send_get_partition($db_name, $tbl_name, $part_vals);
    return $this->recv_get_partition();
  }

  public function send_get_partition($db_name, $tbl_name, $part_vals)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition failed: unknown result");
  }

  public function get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names)
  {
    $this->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
    return $this->recv_get_partition_with_auth();
  }

  public function send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_with_auth failed: unknown result");
  }

  public function get_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $this->send_get_partition_by_name($db_name, $tbl_name, $part_name);
    return $this->recv_get_partition_by_name();
  }

  public function send_get_partition_by_name($db_name, $tbl_name, $part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_by_name failed: unknown result");
  }

  public function get_partitions($db_name, $tbl_name, $max_parts)
  {
    $this->send_get_partitions($db_name, $tbl_name, $max_parts);
    return $this->recv_get_partitions();
  }

  public function send_get_partitions($db_name, $tbl_name, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions failed: unknown result");
  }

  public function get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names)
  {
    $this->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
    return $this->recv_get_partitions_with_auth();
  }

  public function send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_with_auth failed: unknown result");
  }

  public function get_partition_names($db_name, $tbl_name, $max_parts)
  {
    $this->send_get_partition_names($db_name, $tbl_name, $max_parts);
    return $this->recv_get_partition_names();
  }

  public function send_get_partition_names($db_name, $tbl_name, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_names failed: unknown result");
  }

  public function get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts)
  {
    $this->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
    return $this->recv_get_partitions_ps();
  }

  public function send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_ps', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_ps()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_ps_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_ps failed: unknown result");
  }

  public function get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names)
  {
    $this->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
    return $this->recv_get_partitions_ps_with_auth();
  }

  public function send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_ps_with_auth', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_ps_with_auth()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_ps_with_auth_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_ps_with_auth failed: unknown result");
  }

  public function get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts)
  {
    $this->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
    return $this->recv_get_partition_names_ps();
  }

  public function send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_names_ps_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_names_ps', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_names_ps()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_names_ps_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_names_ps_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partition_names_ps failed: unknown result");
  }

  public function get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $this->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
    return $this->recv_get_partitions_by_filter();
  }

  public function send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->filter = $filter;
    $args->max_parts = $max_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_by_filter', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_by_filter()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_by_filter_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_by_filter_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_by_filter failed: unknown result");
  }

  public function get_partitions_by_names($db_name, $tbl_name, $names)
  {
    $this->send_get_partitions_by_names($db_name, $tbl_name, $names);
    return $this->recv_get_partitions_by_names();
  }

  public function send_get_partitions_by_names($db_name, $tbl_name, $names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partitions_by_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->names = $names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partitions_by_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partitions_by_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partitions_by_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partitions_by_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partitions_by_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_partitions_by_names failed: unknown result");
  }

  public function alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
  {
    $this->send_alter_partition($db_name, $tbl_name, $new_part);
    $this->recv_alter_partition();
  }

  public function send_alter_partition($db_name, $tbl_name, \metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_partitions($db_name, $tbl_name, $new_parts)
  {
    $this->send_alter_partitions($db_name, $tbl_name, $new_parts);
    $this->recv_alter_partitions();
  }

  public function send_alter_partitions($db_name, $tbl_name, $new_parts)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partitions_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_parts = $new_parts;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partitions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partitions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partitions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partitions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partitions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $this->send_alter_partition_with_environment_context($db_name, $tbl_name, $new_part, $environment_context);
    $this->recv_alter_partition_with_environment_context();
  }

  public function send_alter_partition_with_environment_context($db_name, $tbl_name, \metastore\Partition $new_part, \metastore\EnvironmentContext $environment_context)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->new_part = $new_part;
    $args->environment_context = $environment_context;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_partition_with_environment_context', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_partition_with_environment_context', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_partition_with_environment_context()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_partition_with_environment_context_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function rename_partition($db_name, $tbl_name, $part_vals, \metastore\Partition $new_part)
  {
    $this->send_rename_partition($db_name, $tbl_name, $part_vals, $new_part);
    $this->recv_rename_partition();
  }

  public function send_rename_partition($db_name, $tbl_name, $part_vals, \metastore\Partition $new_part)
  {
    $args = new \metastore\ThriftHiveMetastore_rename_partition_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->new_part = $new_part;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'rename_partition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('rename_partition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_rename_partition()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_rename_partition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_rename_partition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function get_config_value($name, $defaultValue)
  {
    $this->send_get_config_value($name, $defaultValue);
    return $this->recv_get_config_value();
  }

  public function send_get_config_value($name, $defaultValue)
  {
    $args = new \metastore\ThriftHiveMetastore_get_config_value_args();
    $args->name = $name;
    $args->defaultValue = $defaultValue;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_config_value', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_config_value', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_config_value()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_config_value_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_config_value_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_config_value failed: unknown result");
  }

  public function partition_name_to_vals($part_name)
  {
    $this->send_partition_name_to_vals($part_name);
    return $this->recv_partition_name_to_vals();
  }

  public function send_partition_name_to_vals($part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_partition_name_to_vals_args();
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'partition_name_to_vals', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_partition_name_to_vals()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_partition_name_to_vals_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_partition_name_to_vals_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("partition_name_to_vals failed: unknown result");
  }

  public function partition_name_to_spec($part_name)
  {
    $this->send_partition_name_to_spec($part_name);
    return $this->recv_partition_name_to_spec();
  }

  public function send_partition_name_to_spec($part_name)
  {
    $args = new \metastore\ThriftHiveMetastore_partition_name_to_spec_args();
    $args->part_name = $part_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'partition_name_to_spec', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_partition_name_to_spec()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_partition_name_to_spec_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_partition_name_to_spec_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("partition_name_to_spec failed: unknown result");
  }

  public function markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType)
  {
    $this->send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType);
    $this->recv_markPartitionForEvent();
  }

  public function send_markPartitionForEvent($db_name, $tbl_name, $part_vals, $eventType)
  {
    $args = new \metastore\ThriftHiveMetastore_markPartitionForEvent_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->eventType = $eventType;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'markPartitionForEvent', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('markPartitionForEvent', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_markPartitionForEvent()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_markPartitionForEvent_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_markPartitionForEvent_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    if ($result->o5 !== null) {
      throw $result->o5;
    }
    if ($result->o6 !== null) {
      throw $result->o6;
    }
    return;
  }

  public function isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType)
  {
    $this->send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType);
    return $this->recv_isPartitionMarkedForEvent();
  }

  public function send_isPartitionMarkedForEvent($db_name, $tbl_name, $part_vals, $eventType)
  {
    $args = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_vals = $part_vals;
    $args->eventType = $eventType;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isPartitionMarkedForEvent', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isPartitionMarkedForEvent', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isPartitionMarkedForEvent()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_isPartitionMarkedForEvent_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    if ($result->o5 !== null) {
      throw $result->o5;
    }
    if ($result->o6 !== null) {
      throw $result->o6;
    }
    throw new \Exception("isPartitionMarkedForEvent failed: unknown result");
  }

  public function add_index(\metastore\Index $new_index, \metastore\Table $index_table)
  {
    $this->send_add_index($new_index, $index_table);
    return $this->recv_add_index();
  }

  public function send_add_index(\metastore\Index $new_index, \metastore\Table $index_table)
  {
    $args = new \metastore\ThriftHiveMetastore_add_index_args();
    $args->new_index = $new_index;
    $args->index_table = $index_table;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("add_index failed: unknown result");
  }

  public function alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
  {
    $this->send_alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
    $this->recv_alter_index();
  }

  public function send_alter_index($dbname, $base_tbl_name, $idx_name, \metastore\Index $new_idx)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_index_args();
    $args->dbname = $dbname;
    $args->base_tbl_name = $base_tbl_name;
    $args->idx_name = $idx_name;
    $args->new_idx = $new_idx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_index', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_index', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_index()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_index_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_index_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    return;
  }

  public function drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
  {
    $this->send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
    return $this->recv_drop_index_by_name();
  }

  public function send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_index_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->index_name = $index_name;
    $args->deleteData = $deleteData;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_index_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_index_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_index_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_index_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_index_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_index_by_name failed: unknown result");
  }

  public function get_index_by_name($db_name, $tbl_name, $index_name)
  {
    $this->send_get_index_by_name($db_name, $tbl_name, $index_name);
    return $this->recv_get_index_by_name();
  }

  public function send_get_index_by_name($db_name, $tbl_name, $index_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_index_by_name_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->index_name = $index_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_index_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_index_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_index_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_index_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_index_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_index_by_name failed: unknown result");
  }

  public function get_indexes($db_name, $tbl_name, $max_indexes)
  {
    $this->send_get_indexes($db_name, $tbl_name, $max_indexes);
    return $this->recv_get_indexes();
  }

  public function send_get_indexes($db_name, $tbl_name, $max_indexes)
  {
    $args = new \metastore\ThriftHiveMetastore_get_indexes_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_indexes = $max_indexes;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_indexes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_indexes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_indexes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_indexes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_indexes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_indexes failed: unknown result");
  }

  public function get_index_names($db_name, $tbl_name, $max_indexes)
  {
    $this->send_get_index_names($db_name, $tbl_name, $max_indexes);
    return $this->recv_get_index_names();
  }

  public function send_get_index_names($db_name, $tbl_name, $max_indexes)
  {
    $args = new \metastore\ThriftHiveMetastore_get_index_names_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->max_indexes = $max_indexes;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_index_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_index_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_index_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_index_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_index_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_index_names failed: unknown result");
  }

  public function update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $this->send_update_table_column_statistics($stats_obj);
    return $this->recv_update_table_column_statistics();
  }

  public function send_update_table_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $args = new \metastore\ThriftHiveMetastore_update_table_column_statistics_args();
    $args->stats_obj = $stats_obj;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("update_table_column_statistics failed: unknown result");
  }

  public function update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $this->send_update_partition_column_statistics($stats_obj);
    return $this->recv_update_partition_column_statistics();
  }

  public function send_update_partition_column_statistics(\metastore\ColumnStatistics $stats_obj)
  {
    $args = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_args();
    $args->stats_obj = $stats_obj;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'update_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('update_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_update_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_update_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_update_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("update_partition_column_statistics failed: unknown result");
  }

  public function get_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $this->send_get_table_column_statistics($db_name, $tbl_name, $col_name);
    return $this->recv_get_table_column_statistics();
  }

  public function send_get_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_table_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("get_table_column_statistics failed: unknown result");
  }

  public function get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $this->send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
    return $this->recv_get_partition_column_statistics();
  }

  public function send_get_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("get_partition_column_statistics failed: unknown result");
  }

  public function delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $this->send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name);
    return $this->recv_delete_partition_column_statistics();
  }

  public function send_delete_partition_column_statistics($db_name, $tbl_name, $part_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->part_name = $part_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'delete_partition_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('delete_partition_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_delete_partition_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_delete_partition_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_delete_partition_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("delete_partition_column_statistics failed: unknown result");
  }

  public function delete_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $this->send_delete_table_column_statistics($db_name, $tbl_name, $col_name);
    return $this->recv_delete_table_column_statistics();
  }

  public function send_delete_table_column_statistics($db_name, $tbl_name, $col_name)
  {
    $args = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_args();
    $args->db_name = $db_name;
    $args->tbl_name = $tbl_name;
    $args->col_name = $col_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'delete_table_column_statistics', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('delete_table_column_statistics', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_delete_table_column_statistics()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_delete_table_column_statistics_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_delete_table_column_statistics_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    if ($result->o4 !== null) {
      throw $result->o4;
    }
    throw new \Exception("delete_table_column_statistics failed: unknown result");
  }

  public function create_user(\metastore\User $user)
  {
    $this->send_create_user($user);
    return $this->recv_create_user();
  }

  public function send_create_user(\metastore\User $user)
  {
    $args = new \metastore\ThriftHiveMetastore_create_user_args();
    $args->user = $user;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_user', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_user', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_user()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_user_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_user_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("create_user failed: unknown result");
  }

  public function drop_user($user_name)
  {
    $this->send_drop_user($user_name);
    return $this->recv_drop_user();
  }

  public function send_drop_user($user_name)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_user_args();
    $args->user_name = $user_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_user', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_user', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_user()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_user_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_user_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("drop_user failed: unknown result");
  }

  public function modify_user(\metastore\User $user)
  {
    $this->send_modify_user($user);
    return $this->recv_modify_user();
  }

  public function send_modify_user(\metastore\User $user)
  {
    $args = new \metastore\ThriftHiveMetastore_modify_user_args();
    $args->user = $user;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modify_user', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modify_user', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modify_user()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modify_user_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modify_user_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("modify_user failed: unknown result");
  }

  public function list_users_names()
  {
    $this->send_list_users_names();
    return $this->recv_list_users_names();
  }

  public function send_list_users_names()
  {
    $args = new \metastore\ThriftHiveMetastore_list_users_names_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_users_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_users_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_users_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_users_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_users_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_users_names failed: unknown result");
  }

  public function list_users(\metastore\Database $db)
  {
    $this->send_list_users($db);
    return $this->recv_list_users();
  }

  public function send_list_users(\metastore\Database $db)
  {
    $args = new \metastore\ThriftHiveMetastore_list_users_args();
    $args->db = $db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_users', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_users', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_users()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_users_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_users_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_users failed: unknown result");
  }

  public function authentication($user_name, $passwd)
  {
    $this->send_authentication($user_name, $passwd);
    return $this->recv_authentication();
  }

  public function send_authentication($user_name, $passwd)
  {
    $args = new \metastore\ThriftHiveMetastore_authentication_args();
    $args->user_name = $user_name;
    $args->passwd = $passwd;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'authentication', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('authentication', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_authentication()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_authentication_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_authentication_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("authentication failed: unknown result");
  }

  public function user_authority_check(\metastore\User $user, \metastore\Table $tbl, $ops)
  {
    $this->send_user_authority_check($user, $tbl, $ops);
    return $this->recv_user_authority_check();
  }

  public function send_user_authority_check(\metastore\User $user, \metastore\Table $tbl, $ops)
  {
    $args = new \metastore\ThriftHiveMetastore_user_authority_check_args();
    $args->user = $user;
    $args->tbl = $tbl;
    $args->ops = $ops;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'user_authority_check', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('user_authority_check', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_user_authority_check()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_user_authority_check_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_user_authority_check_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("user_authority_check failed: unknown result");
  }

  public function create_role(\metastore\Role $role)
  {
    $this->send_create_role($role);
    return $this->recv_create_role();
  }

  public function send_create_role(\metastore\Role $role)
  {
    $args = new \metastore\ThriftHiveMetastore_create_role_args();
    $args->role = $role;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_role()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("create_role failed: unknown result");
  }

  public function drop_role($role_name)
  {
    $this->send_drop_role($role_name);
    return $this->recv_drop_role();
  }

  public function send_drop_role($role_name)
  {
    $args = new \metastore\ThriftHiveMetastore_drop_role_args();
    $args->role_name = $role_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'drop_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('drop_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_drop_role()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_drop_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_drop_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("drop_role failed: unknown result");
  }

  public function get_role_names()
  {
    $this->send_get_role_names();
    return $this->recv_get_role_names();
  }

  public function send_get_role_names()
  {
    $args = new \metastore\ThriftHiveMetastore_get_role_names_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_role_names', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_role_names', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_role_names()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_role_names_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_role_names_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_role_names failed: unknown result");
  }

  public function grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
  {
    $this->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
    return $this->recv_grant_role();
  }

  public function send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_role_args();
    $args->role_name = $role_name;
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $args->grantor = $grantor;
    $args->grantorType = $grantorType;
    $args->grant_option = $grant_option;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_role()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_role failed: unknown result");
  }

  public function revoke_role($role_name, $principal_name, $principal_type)
  {
    $this->send_revoke_role($role_name, $principal_name, $principal_type);
    return $this->recv_revoke_role();
  }

  public function send_revoke_role($role_name, $principal_name, $principal_type)
  {
    $args = new \metastore\ThriftHiveMetastore_revoke_role_args();
    $args->role_name = $role_name;
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'revoke_role', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('revoke_role', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_revoke_role()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_revoke_role_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_revoke_role_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("revoke_role failed: unknown result");
  }

  public function list_roles($principal_name, $principal_type)
  {
    $this->send_list_roles($principal_name, $principal_type);
    return $this->recv_list_roles();
  }

  public function send_list_roles($principal_name, $principal_type)
  {
    $args = new \metastore\ThriftHiveMetastore_list_roles_args();
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_roles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_roles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_roles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_roles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_roles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_roles failed: unknown result");
  }

  public function get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, $group_names)
  {
    $this->send_get_privilege_set($hiveObject, $user_name, $group_names);
    return $this->recv_get_privilege_set();
  }

  public function send_get_privilege_set(\metastore\HiveObjectRef $hiveObject, $user_name, $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_get_privilege_set_args();
    $args->hiveObject = $hiveObject;
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_privilege_set', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_privilege_set', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_privilege_set()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_privilege_set_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_privilege_set_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_privilege_set failed: unknown result");
  }

  public function list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
  {
    $this->send_list_privileges($principal_name, $principal_type, $hiveObject);
    return $this->recv_list_privileges();
  }

  public function send_list_privileges($principal_name, $principal_type, \metastore\HiveObjectRef $hiveObject)
  {
    $args = new \metastore\ThriftHiveMetastore_list_privileges_args();
    $args->principal_name = $principal_name;
    $args->principal_type = $principal_type;
    $args->hiveObject = $hiveObject;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'list_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('list_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_list_privileges()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_list_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_list_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("list_privileges failed: unknown result");
  }

  public function grant_privileges(\metastore\PrivilegeBag $privileges)
  {
    $this->send_grant_privileges($privileges);
    return $this->recv_grant_privileges();
  }

  public function send_grant_privileges(\metastore\PrivilegeBag $privileges)
  {
    $args = new \metastore\ThriftHiveMetastore_grant_privileges_args();
    $args->privileges = $privileges;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'grant_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('grant_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_grant_privileges()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_grant_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_grant_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("grant_privileges failed: unknown result");
  }

  public function revoke_privileges(\metastore\PrivilegeBag $privileges)
  {
    $this->send_revoke_privileges($privileges);
    return $this->recv_revoke_privileges();
  }

  public function send_revoke_privileges(\metastore\PrivilegeBag $privileges)
  {
    $args = new \metastore\ThriftHiveMetastore_revoke_privileges_args();
    $args->privileges = $privileges;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'revoke_privileges', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('revoke_privileges', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_revoke_privileges()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_revoke_privileges_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_revoke_privileges_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("revoke_privileges failed: unknown result");
  }

  public function set_ugi($user_name, $group_names)
  {
    $this->send_set_ugi($user_name, $group_names);
    return $this->recv_set_ugi();
  }

  public function send_set_ugi($user_name, $group_names)
  {
    $args = new \metastore\ThriftHiveMetastore_set_ugi_args();
    $args->user_name = $user_name;
    $args->group_names = $group_names;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'set_ugi', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('set_ugi', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_set_ugi()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_set_ugi_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_set_ugi_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("set_ugi failed: unknown result");
  }

  public function get_delegation_token($token_owner, $renewer_kerberos_principal_name)
  {
    $this->send_get_delegation_token($token_owner, $renewer_kerberos_principal_name);
    return $this->recv_get_delegation_token();
  }

  public function send_get_delegation_token($token_owner, $renewer_kerberos_principal_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_delegation_token_args();
    $args->token_owner = $token_owner;
    $args->renewer_kerberos_principal_name = $renewer_kerberos_principal_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_delegation_token failed: unknown result");
  }

  public function renew_delegation_token($token_str_form)
  {
    $this->send_renew_delegation_token($token_str_form);
    return $this->recv_renew_delegation_token();
  }

  public function send_renew_delegation_token($token_str_form)
  {
    $args = new \metastore\ThriftHiveMetastore_renew_delegation_token_args();
    $args->token_str_form = $token_str_form;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'renew_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_renew_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_renew_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_renew_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("renew_delegation_token failed: unknown result");
  }

  public function cancel_delegation_token($token_str_form)
  {
    $this->send_cancel_delegation_token($token_str_form);
    $this->recv_cancel_delegation_token();
  }

  public function send_cancel_delegation_token($token_str_form)
  {
    $args = new \metastore\ThriftHiveMetastore_cancel_delegation_token_args();
    $args->token_str_form = $token_str_form;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cancel_delegation_token', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cancel_delegation_token()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_cancel_delegation_token_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_cancel_delegation_token_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function create_file($node_name, $repnr, $db_name, $table_name, $values)
  {
    $this->send_create_file($node_name, $repnr, $db_name, $table_name, $values);
    return $this->recv_create_file();
  }

  public function send_create_file($node_name, $repnr, $db_name, $table_name, $values)
  {
    $args = new \metastore\ThriftHiveMetastore_create_file_args();
    $args->node_name = $node_name;
    $args->repnr = $repnr;
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $args->values = $values;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_file', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_file', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_file()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_file_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_file_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("create_file failed: unknown result");
  }

  public function create_file_by_policy(\metastore\CreatePolicy $policy, $repnr, $db_name, $table_name, $values)
  {
    $this->send_create_file_by_policy($policy, $repnr, $db_name, $table_name, $values);
    return $this->recv_create_file_by_policy();
  }

  public function send_create_file_by_policy(\metastore\CreatePolicy $policy, $repnr, $db_name, $table_name, $values)
  {
    $args = new \metastore\ThriftHiveMetastore_create_file_by_policy_args();
    $args->policy = $policy;
    $args->repnr = $repnr;
    $args->db_name = $db_name;
    $args->table_name = $table_name;
    $args->values = $values;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_file_by_policy', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_file_by_policy', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_file_by_policy()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_file_by_policy_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_file_by_policy_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("create_file_by_policy failed: unknown result");
  }

  public function close_file(\metastore\SFile $file)
  {
    $this->send_close_file($file);
    return $this->recv_close_file();
  }

  public function send_close_file(\metastore\SFile $file)
  {
    $args = new \metastore\ThriftHiveMetastore_close_file_args();
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'close_file', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('close_file', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_close_file()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_close_file_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_close_file_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("close_file failed: unknown result");
  }

  public function online_filelocation(\metastore\SFile $file)
  {
    $this->send_online_filelocation($file);
    return $this->recv_online_filelocation();
  }

  public function send_online_filelocation(\metastore\SFile $file)
  {
    $args = new \metastore\ThriftHiveMetastore_online_filelocation_args();
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'online_filelocation', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('online_filelocation', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_online_filelocation()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_online_filelocation_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_online_filelocation_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("online_filelocation failed: unknown result");
  }

  public function toggle_safemode()
  {
    $this->send_toggle_safemode();
    return $this->recv_toggle_safemode();
  }

  public function send_toggle_safemode()
  {
    $args = new \metastore\ThriftHiveMetastore_toggle_safemode_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'toggle_safemode', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('toggle_safemode', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_toggle_safemode()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_toggle_safemode_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_toggle_safemode_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("toggle_safemode failed: unknown result");
  }

  public function get_file_by_id($fid)
  {
    $this->send_get_file_by_id($fid);
    return $this->recv_get_file_by_id();
  }

  public function send_get_file_by_id($fid)
  {
    $args = new \metastore\ThriftHiveMetastore_get_file_by_id_args();
    $args->fid = $fid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_file_by_id', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_file_by_id', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_file_by_id()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_file_by_id_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_file_by_id_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_file_by_id failed: unknown result");
  }

  public function get_file_by_name($node, $devid, $location)
  {
    $this->send_get_file_by_name($node, $devid, $location);
    return $this->recv_get_file_by_name();
  }

  public function send_get_file_by_name($node, $devid, $location)
  {
    $args = new \metastore\ThriftHiveMetastore_get_file_by_name_args();
    $args->node = $node;
    $args->devid = $devid;
    $args->location = $location;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_file_by_name', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_file_by_name', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_file_by_name()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_file_by_name_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_file_by_name_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_file_by_name failed: unknown result");
  }

  public function rm_file_logical(\metastore\SFile $file)
  {
    $this->send_rm_file_logical($file);
    return $this->recv_rm_file_logical();
  }

  public function send_rm_file_logical(\metastore\SFile $file)
  {
    $args = new \metastore\ThriftHiveMetastore_rm_file_logical_args();
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'rm_file_logical', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('rm_file_logical', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_rm_file_logical()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_rm_file_logical_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_rm_file_logical_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("rm_file_logical failed: unknown result");
  }

  public function restore_file(\metastore\SFile $file)
  {
    $this->send_restore_file($file);
    return $this->recv_restore_file();
  }

  public function send_restore_file(\metastore\SFile $file)
  {
    $args = new \metastore\ThriftHiveMetastore_restore_file_args();
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'restore_file', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('restore_file', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_restore_file()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_restore_file_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_restore_file_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("restore_file failed: unknown result");
  }

  public function rm_file_physical(\metastore\SFile $file)
  {
    $this->send_rm_file_physical($file);
    return $this->recv_rm_file_physical();
  }

  public function send_rm_file_physical(\metastore\SFile $file)
  {
    $args = new \metastore\ThriftHiveMetastore_rm_file_physical_args();
    $args->file = $file;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'rm_file_physical', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('rm_file_physical', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_rm_file_physical()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_rm_file_physical_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_rm_file_physical_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("rm_file_physical failed: unknown result");
  }

  public function get_node($node_name)
  {
    $this->send_get_node($node_name);
    return $this->recv_get_node();
  }

  public function send_get_node($node_name)
  {
    $args = new \metastore\ThriftHiveMetastore_get_node_args();
    $args->node_name = $node_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_node', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_node', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_node()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_node_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_node_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_node failed: unknown result");
  }

  public function add_node($node_name, $ipl)
  {
    $this->send_add_node($node_name, $ipl);
    return $this->recv_add_node();
  }

  public function send_add_node($node_name, $ipl)
  {
    $args = new \metastore\ThriftHiveMetastore_add_node_args();
    $args->node_name = $node_name;
    $args->ipl = $ipl;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'add_node', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('add_node', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_add_node()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_add_node_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_add_node_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("add_node failed: unknown result");
  }

  public function del_node($node_name)
  {
    $this->send_del_node($node_name);
    return $this->recv_del_node();
  }

  public function send_del_node($node_name)
  {
    $args = new \metastore\ThriftHiveMetastore_del_node_args();
    $args->node_name = $node_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'del_node', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('del_node', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_del_node()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_del_node_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_del_node_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("del_node failed: unknown result");
  }

  public function create_device($devid, $prop, $node_name)
  {
    $this->send_create_device($devid, $prop, $node_name);
    return $this->recv_create_device();
  }

  public function send_create_device($devid, $prop, $node_name)
  {
    $args = new \metastore\ThriftHiveMetastore_create_device_args();
    $args->devid = $devid;
    $args->prop = $prop;
    $args->node_name = $node_name;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'create_device', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('create_device', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_create_device()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_create_device_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_create_device_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("create_device failed: unknown result");
  }

  public function get_device($devid)
  {
    $this->send_get_device($devid);
    return $this->recv_get_device();
  }

  public function send_get_device($devid)
  {
    $args = new \metastore\ThriftHiveMetastore_get_device_args();
    $args->devid = $devid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_device', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_device', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_device()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_device_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_device_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("get_device failed: unknown result");
  }

  public function del_device($devid)
  {
    $this->send_del_device($devid);
    return $this->recv_del_device();
  }

  public function send_del_device($devid)
  {
    $args = new \metastore\ThriftHiveMetastore_del_device_args();
    $args->devid = $devid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'del_device', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('del_device', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_del_device()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_del_device_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_del_device_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("del_device failed: unknown result");
  }

  public function modify_device(\metastore\Device $dev, \metastore\Node $node)
  {
    $this->send_modify_device($dev, $node);
    return $this->recv_modify_device();
  }

  public function send_modify_device(\metastore\Device $dev, \metastore\Node $node)
  {
    $args = new \metastore\ThriftHiveMetastore_modify_device_args();
    $args->dev = $dev;
    $args->node = $node;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modify_device', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modify_device', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modify_device()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modify_device_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modify_device_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("modify_device failed: unknown result");
  }

  public function alter_node($node_name, $ipl, $status)
  {
    $this->send_alter_node($node_name, $ipl, $status);
    return $this->recv_alter_node();
  }

  public function send_alter_node($node_name, $ipl, $status)
  {
    $args = new \metastore\ThriftHiveMetastore_alter_node_args();
    $args->node_name = $node_name;
    $args->ipl = $ipl;
    $args->status = $status;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'alter_node', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('alter_node', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_alter_node()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_alter_node_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_alter_node_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("alter_node failed: unknown result");
  }

  public function find_best_nodes($nr)
  {
    $this->send_find_best_nodes($nr);
    return $this->recv_find_best_nodes();
  }

  public function send_find_best_nodes($nr)
  {
    $args = new \metastore\ThriftHiveMetastore_find_best_nodes_args();
    $args->nr = $nr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'find_best_nodes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('find_best_nodes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_find_best_nodes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_find_best_nodes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_find_best_nodes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("find_best_nodes failed: unknown result");
  }

  public function find_best_nodes_in_groups($dbName, $tableName, $nr, $policy)
  {
    $this->send_find_best_nodes_in_groups($dbName, $tableName, $nr, $policy);
    return $this->recv_find_best_nodes_in_groups();
  }

  public function send_find_best_nodes_in_groups($dbName, $tableName, $nr, $policy)
  {
    $args = new \metastore\ThriftHiveMetastore_find_best_nodes_in_groups_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->nr = $nr;
    $args->policy = $policy;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'find_best_nodes_in_groups', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('find_best_nodes_in_groups', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_find_best_nodes_in_groups()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_find_best_nodes_in_groups_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_find_best_nodes_in_groups_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("find_best_nodes_in_groups failed: unknown result");
  }

  public function get_all_nodes()
  {
    $this->send_get_all_nodes();
    return $this->recv_get_all_nodes();
  }

  public function send_get_all_nodes()
  {
    $args = new \metastore\ThriftHiveMetastore_get_all_nodes_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get_all_nodes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get_all_nodes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get_all_nodes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_get_all_nodes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_get_all_nodes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("get_all_nodes failed: unknown result");
  }

  public function getDMStatus()
  {
    $this->send_getDMStatus();
    return $this->recv_getDMStatus();
  }

  public function send_getDMStatus()
  {
    $args = new \metastore\ThriftHiveMetastore_getDMStatus_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getDMStatus', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getDMStatus', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getDMStatus()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getDMStatus_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getDMStatus_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getDMStatus failed: unknown result");
  }

  public function getNodeInfo()
  {
    $this->send_getNodeInfo();
    return $this->recv_getNodeInfo();
  }

  public function send_getNodeInfo()
  {
    $args = new \metastore\ThriftHiveMetastore_getNodeInfo_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getNodeInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getNodeInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getNodeInfo()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getNodeInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getNodeInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getNodeInfo failed: unknown result");
  }

  public function migrate_in(\metastore\Table $tbl, $files, $idxs, $from_db, $to_devid, $fileMap)
  {
    $this->send_migrate_in($tbl, $files, $idxs, $from_db, $to_devid, $fileMap);
    return $this->recv_migrate_in();
  }

  public function send_migrate_in(\metastore\Table $tbl, $files, $idxs, $from_db, $to_devid, $fileMap)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate_in_args();
    $args->tbl = $tbl;
    $args->files = $files;
    $args->idxs = $idxs;
    $args->from_db = $from_db;
    $args->to_devid = $to_devid;
    $args->fileMap = $fileMap;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate_in', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate_in', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate_in()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate_in_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate_in_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate_in failed: unknown result");
  }

  public function migrate_stage1($dbName, $tableName, $files, $to_db)
  {
    $this->send_migrate_stage1($dbName, $tableName, $files, $to_db);
    return $this->recv_migrate_stage1();
  }

  public function send_migrate_stage1($dbName, $tableName, $files, $to_db)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate_stage1_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->files = $files;
    $args->to_db = $to_db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate_stage1', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate_stage1', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate_stage1()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate_stage1_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate_stage1_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate_stage1 failed: unknown result");
  }

  public function migrate_stage2($dbName, $tableName, $files, $from_db, $to_db, $to_devid)
  {
    $this->send_migrate_stage2($dbName, $tableName, $files, $from_db, $to_db, $to_devid);
    return $this->recv_migrate_stage2();
  }

  public function send_migrate_stage2($dbName, $tableName, $files, $from_db, $to_db, $to_devid)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate_stage2_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->files = $files;
    $args->from_db = $from_db;
    $args->to_db = $to_db;
    $args->to_devid = $to_devid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate_stage2', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate_stage2', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate_stage2()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate_stage2_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate_stage2_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate_stage2 failed: unknown result");
  }

  public function migrate2_in(\metastore\Table $tbl, $parts, $idxs, $from_db, $to_nas_devid, $fileMap)
  {
    $this->send_migrate2_in($tbl, $parts, $idxs, $from_db, $to_nas_devid, $fileMap);
    return $this->recv_migrate2_in();
  }

  public function send_migrate2_in(\metastore\Table $tbl, $parts, $idxs, $from_db, $to_nas_devid, $fileMap)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate2_in_args();
    $args->tbl = $tbl;
    $args->parts = $parts;
    $args->idxs = $idxs;
    $args->from_db = $from_db;
    $args->to_nas_devid = $to_nas_devid;
    $args->fileMap = $fileMap;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate2_in', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate2_in', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate2_in()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate2_in_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate2_in_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate2_in failed: unknown result");
  }

  public function migrate2_stage1($dbName, $tableName, $partNames, $to_db)
  {
    $this->send_migrate2_stage1($dbName, $tableName, $partNames, $to_db);
    return $this->recv_migrate2_stage1();
  }

  public function send_migrate2_stage1($dbName, $tableName, $partNames, $to_db)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate2_stage1_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->partNames = $partNames;
    $args->to_db = $to_db;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate2_stage1', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate2_stage1', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate2_stage1()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate2_stage1_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate2_stage1_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate2_stage1 failed: unknown result");
  }

  public function migrate2_stage2($dbName, $tableName, $partNames, $from_db, $to_db, $to_nas_devid)
  {
    $this->send_migrate2_stage2($dbName, $tableName, $partNames, $from_db, $to_db, $to_nas_devid);
    return $this->recv_migrate2_stage2();
  }

  public function send_migrate2_stage2($dbName, $tableName, $partNames, $from_db, $to_db, $to_nas_devid)
  {
    $args = new \metastore\ThriftHiveMetastore_migrate2_stage2_args();
    $args->dbName = $dbName;
    $args->tableName = $tableName;
    $args->partNames = $partNames;
    $args->from_db = $from_db;
    $args->to_db = $to_db;
    $args->to_nas_devid = $to_nas_devid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'migrate2_stage2', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('migrate2_stage2', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_migrate2_stage2()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_migrate2_stage2_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_migrate2_stage2_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("migrate2_stage2 failed: unknown result");
  }

  public function getMP($node_name, $devid)
  {
    $this->send_getMP($node_name, $devid);
    return $this->recv_getMP();
  }

  public function send_getMP($node_name, $devid)
  {
    $args = new \metastore\ThriftHiveMetastore_getMP_args();
    $args->node_name = $node_name;
    $args->devid = $devid;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getMP', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getMP', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getMP()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getMP_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getMP_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getMP failed: unknown result");
  }

  public function getSessionId()
  {
    $this->send_getSessionId();
    return $this->recv_getSessionId();
  }

  public function send_getSessionId()
  {
    $args = new \metastore\ThriftHiveMetastore_getSessionId_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getSessionId', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getSessionId', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getSessionId()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getSessionId_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getSessionId_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getSessionId failed: unknown result");
  }

  public function createSchema(\metastore\GlobalSchema $schema)
  {
    $this->send_createSchema($schema);
    return $this->recv_createSchema();
  }

  public function send_createSchema(\metastore\GlobalSchema $schema)
  {
    $args = new \metastore\ThriftHiveMetastore_createSchema_args();
    $args->schema = $schema;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createSchema', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createSchema', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createSchema()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_createSchema_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_createSchema_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("createSchema failed: unknown result");
  }

  public function modifySchema($schemaName, \metastore\GlobalSchema $schema)
  {
    $this->send_modifySchema($schemaName, $schema);
    return $this->recv_modifySchema();
  }

  public function send_modifySchema($schemaName, \metastore\GlobalSchema $schema)
  {
    $args = new \metastore\ThriftHiveMetastore_modifySchema_args();
    $args->schemaName = $schemaName;
    $args->schema = $schema;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modifySchema', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modifySchema', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modifySchema()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modifySchema_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modifySchema_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("modifySchema failed: unknown result");
  }

  public function deleteSchema($schemaName)
  {
    $this->send_deleteSchema($schemaName);
    return $this->recv_deleteSchema();
  }

  public function send_deleteSchema($schemaName)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteSchema_args();
    $args->schemaName = $schemaName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteSchema', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteSchema', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteSchema()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteSchema_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteSchema_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteSchema failed: unknown result");
  }

  public function listSchemas()
  {
    $this->send_listSchemas();
    return $this->recv_listSchemas();
  }

  public function send_listSchemas()
  {
    $args = new \metastore\ThriftHiveMetastore_listSchemas_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listSchemas', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listSchemas', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listSchemas()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listSchemas_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listSchemas_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listSchemas failed: unknown result");
  }

  public function getSchemaByName($schemaName)
  {
    $this->send_getSchemaByName($schemaName);
    return $this->recv_getSchemaByName();
  }

  public function send_getSchemaByName($schemaName)
  {
    $args = new \metastore\ThriftHiveMetastore_getSchemaByName_args();
    $args->schemaName = $schemaName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getSchemaByName', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getSchemaByName', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getSchemaByName()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getSchemaByName_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getSchemaByName_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("getSchemaByName failed: unknown result");
  }

  public function getTableNodeGroups($dbName, $tabName)
  {
    $this->send_getTableNodeGroups($dbName, $tabName);
    return $this->recv_getTableNodeGroups();
  }

  public function send_getTableNodeGroups($dbName, $tabName)
  {
    $args = new \metastore\ThriftHiveMetastore_getTableNodeGroups_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableNodeGroups', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableNodeGroups', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableNodeGroups()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getTableNodeGroups_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getTableNodeGroups_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getTableNodeGroups failed: unknown result");
  }

  public function getTableNodeFiles($dbName, $tabName, $nodeName)
  {
    $this->send_getTableNodeFiles($dbName, $tabName, $nodeName);
    return $this->recv_getTableNodeFiles();
  }

  public function send_getTableNodeFiles($dbName, $tabName, $nodeName)
  {
    $args = new \metastore\ThriftHiveMetastore_getTableNodeFiles_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $args->nodeName = $nodeName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableNodeFiles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableNodeFiles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableNodeFiles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_getTableNodeFiles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_getTableNodeFiles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("getTableNodeFiles failed: unknown result");
  }

  public function listTableFiles($dbName, $tabName, $from, $to)
  {
    $this->send_listTableFiles($dbName, $tabName, $from, $to);
    return $this->recv_listTableFiles();
  }

  public function send_listTableFiles($dbName, $tabName, $from, $to)
  {
    $args = new \metastore\ThriftHiveMetastore_listTableFiles_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $args->from = $from;
    $args->to = $to;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listTableFiles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listTableFiles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listTableFiles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listTableFiles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listTableFiles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listTableFiles failed: unknown result");
  }

  public function listFilesByDigest($digest)
  {
    $this->send_listFilesByDigest($digest);
    return $this->recv_listFilesByDigest();
  }

  public function send_listFilesByDigest($digest)
  {
    $args = new \metastore\ThriftHiveMetastore_listFilesByDigest_args();
    $args->digest = $digest;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listFilesByDigest', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listFilesByDigest', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listFilesByDigest()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listFilesByDigest_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listFilesByDigest_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listFilesByDigest failed: unknown result");
  }

  public function filterTableFiles($dbName, $tabName, $values)
  {
    $this->send_filterTableFiles($dbName, $tabName, $values);
    return $this->recv_filterTableFiles();
  }

  public function send_filterTableFiles($dbName, $tabName, $values)
  {
    $args = new \metastore\ThriftHiveMetastore_filterTableFiles_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $args->values = $values;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'filterTableFiles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('filterTableFiles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_filterTableFiles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_filterTableFiles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_filterTableFiles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("filterTableFiles failed: unknown result");
  }

  public function truncTableFiles($dbName, $tabName)
  {
    $this->send_truncTableFiles($dbName, $tabName);
    $this->recv_truncTableFiles();
  }

  public function send_truncTableFiles($dbName, $tabName)
  {
    $args = new \metastore\ThriftHiveMetastore_truncTableFiles_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'truncTableFiles', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('truncTableFiles', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_truncTableFiles()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_truncTableFiles_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_truncTableFiles_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    return;
  }

  public function addNodeGroup(\metastore\NodeGroup $ng)
  {
    $this->send_addNodeGroup($ng);
    return $this->recv_addNodeGroup();
  }

  public function send_addNodeGroup(\metastore\NodeGroup $ng)
  {
    $args = new \metastore\ThriftHiveMetastore_addNodeGroup_args();
    $args->ng = $ng;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addNodeGroup', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addNodeGroup', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addNodeGroup()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addNodeGroup_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addNodeGroup_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    throw new \Exception("addNodeGroup failed: unknown result");
  }

  public function modifyNodeGroup($schemaName, \metastore\NodeGroup $ng)
  {
    $this->send_modifyNodeGroup($schemaName, $ng);
    return $this->recv_modifyNodeGroup();
  }

  public function send_modifyNodeGroup($schemaName, \metastore\NodeGroup $ng)
  {
    $args = new \metastore\ThriftHiveMetastore_modifyNodeGroup_args();
    $args->schemaName = $schemaName;
    $args->ng = $ng;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'modifyNodeGroup', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('modifyNodeGroup', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_modifyNodeGroup()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_modifyNodeGroup_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_modifyNodeGroup_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("modifyNodeGroup failed: unknown result");
  }

  public function deleteNodeGroup(\metastore\NodeGroup $ng)
  {
    $this->send_deleteNodeGroup($ng);
    return $this->recv_deleteNodeGroup();
  }

  public function send_deleteNodeGroup(\metastore\NodeGroup $ng)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteNodeGroup_args();
    $args->ng = $ng;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteNodeGroup', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteNodeGroup', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteNodeGroup()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteNodeGroup_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteNodeGroup_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteNodeGroup failed: unknown result");
  }

  public function listNodeGroups()
  {
    $this->send_listNodeGroups();
    return $this->recv_listNodeGroups();
  }

  public function send_listNodeGroups()
  {
    $args = new \metastore\ThriftHiveMetastore_listNodeGroups_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listNodeGroups', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listNodeGroups', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listNodeGroups()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listNodeGroups_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listNodeGroups_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listNodeGroups failed: unknown result");
  }

  public function listDBNodeGroups($dbName)
  {
    $this->send_listDBNodeGroups($dbName);
    return $this->recv_listDBNodeGroups();
  }

  public function send_listDBNodeGroups($dbName)
  {
    $args = new \metastore\ThriftHiveMetastore_listDBNodeGroups_args();
    $args->dbName = $dbName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listDBNodeGroups', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listDBNodeGroups', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listDBNodeGroups()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listDBNodeGroups_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listDBNodeGroups_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listDBNodeGroups failed: unknown result");
  }

  public function listNodeGroupByNames($ngNames)
  {
    $this->send_listNodeGroupByNames($ngNames);
    return $this->recv_listNodeGroupByNames();
  }

  public function send_listNodeGroupByNames($ngNames)
  {
    $args = new \metastore\ThriftHiveMetastore_listNodeGroupByNames_args();
    $args->ngNames = $ngNames;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listNodeGroupByNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listNodeGroupByNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listNodeGroupByNames()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listNodeGroupByNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listNodeGroupByNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listNodeGroupByNames failed: unknown result");
  }

  public function addTableNodeDist($db, $tab, $ng)
  {
    $this->send_addTableNodeDist($db, $tab, $ng);
    return $this->recv_addTableNodeDist();
  }

  public function send_addTableNodeDist($db, $tab, $ng)
  {
    $args = new \metastore\ThriftHiveMetastore_addTableNodeDist_args();
    $args->db = $db;
    $args->tab = $tab;
    $args->ng = $ng;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addTableNodeDist', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addTableNodeDist', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addTableNodeDist()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_addTableNodeDist_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_addTableNodeDist_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("addTableNodeDist failed: unknown result");
  }

  public function deleteTableNodeDist($db, $tab, $ng)
  {
    $this->send_deleteTableNodeDist($db, $tab, $ng);
    return $this->recv_deleteTableNodeDist();
  }

  public function send_deleteTableNodeDist($db, $tab, $ng)
  {
    $args = new \metastore\ThriftHiveMetastore_deleteTableNodeDist_args();
    $args->db = $db;
    $args->tab = $tab;
    $args->ng = $ng;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteTableNodeDist', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteTableNodeDist', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteTableNodeDist()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_deleteTableNodeDist_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_deleteTableNodeDist_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("deleteTableNodeDist failed: unknown result");
  }

  public function listTableNodeDists($dbName, $tabName)
  {
    $this->send_listTableNodeDists($dbName, $tabName);
    return $this->recv_listTableNodeDists();
  }

  public function send_listTableNodeDists($dbName, $tabName)
  {
    $args = new \metastore\ThriftHiveMetastore_listTableNodeDists_args();
    $args->dbName = $dbName;
    $args->tabName = $tabName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'listTableNodeDists', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('listTableNodeDists', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_listTableNodeDists()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_listTableNodeDists_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_listTableNodeDists_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    throw new \Exception("listTableNodeDists failed: unknown result");
  }

  public function assiginSchematoDB($dbName, $schemaName, $fileSplitKeys, $part_keys, $ngs)
  {
    $this->send_assiginSchematoDB($dbName, $schemaName, $fileSplitKeys, $part_keys, $ngs);
    return $this->recv_assiginSchematoDB();
  }

  public function send_assiginSchematoDB($dbName, $schemaName, $fileSplitKeys, $part_keys, $ngs)
  {
    $args = new \metastore\ThriftHiveMetastore_assiginSchematoDB_args();
    $args->dbName = $dbName;
    $args->schemaName = $schemaName;
    $args->fileSplitKeys = $fileSplitKeys;
    $args->part_keys = $part_keys;
    $args->ngs = $ngs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'assiginSchematoDB', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('assiginSchematoDB', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_assiginSchematoDB()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\metastore\ThriftHiveMetastore_assiginSchematoDB_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \metastore\ThriftHiveMetastore_assiginSchematoDB_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->o1 !== null) {
      throw $result->o1;
    }
    if ($result->o2 !== null) {
      throw $result->o2;
    }
    if ($result->o3 !== null) {
      throw $result->o3;
    }
    throw new \Exception("assiginSchematoDB failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class ThriftHiveMetastore_create_attribution_args {
  static $_TSPEC;

  public $db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_attribution_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->db = new \metastore\Database();
            $xfer += $this->db->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_attribution_args');
    if ($this->db !== null) {
      if (!is_object($this->db)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('db', TType::STRUCT, 1);
      $xfer += $this->db->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_attribution_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_attribution_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_attribution_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_attribution_args {
  static $_TSPEC;

  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_attribution_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_attribution_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_attribution_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_attribution_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Database();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_attribution_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_attribution_args {
  static $_TSPEC;

  public $name = null;
  public $deleteData = null;
  public $cascade = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'cascade',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['cascade'])) {
        $this->cascade = $vals['cascade'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_attribution_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->cascade);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_attribution_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cascade !== null) {
      $xfer += $output->writeFieldBegin('cascade', TType::BOOL, 3);
      $xfer += $output->writeBool($this->cascade);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_attribution_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_attribution_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_attribution_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_attribution_args {
  static $_TSPEC;

  public $db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_attribution_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->db = new \metastore\Database();
            $xfer += $this->db->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_attribution_args');
    if ($this->db !== null) {
      if (!is_object($this->db)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('db', TType::STRUCT, 1);
      $xfer += $this->db->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_attribution_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_attribution_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_attribution_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_attributions_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_attributions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_attributions_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_attributions_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Database',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_attributions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size337 = 0;
            $_etype340 = 0;
            $xfer += $input->readListBegin($_etype340, $_size337);
            for ($_i341 = 0; $_i341 < $_size337; ++$_i341)
            {
              $elem342 = null;
              $elem342 = new \metastore\Database();
              $xfer += $elem342->read($input);
              $this->success []= $elem342;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_attributions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter343)
          {
            $xfer += $iter343->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_local_attribution_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_local_attribution_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_local_attribution_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_local_attribution_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_local_attribution_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Database();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_local_attribution_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_lucene_index_names_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_indexes = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_indexes',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_indexes'])) {
        $this->max_indexes = $vals['max_indexes'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_lucene_index_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_indexes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_lucene_index_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_indexes !== null) {
      $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
      $xfer += $output->writeI16($this->max_indexes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_lucene_index_names_result {
  static $_TSPEC;

  public $success = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_lucene_index_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size344 = 0;
            $_etype347 = 0;
            $xfer += $input->readListBegin($_etype347, $_size344);
            for ($_i348 = 0; $_i348 < $_size344; ++$_i348)
            {
              $elem349 = null;
              $xfer += $input->readString($elem349);
              $this->success []= $elem349;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_lucene_index_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter350)
          {
            $xfer += $output->writeString($iter350);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_busi_type_cols_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_busi_type_cols_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_busi_type_cols_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_busi_type_cols_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\BusiTypeColumn',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_busi_type_cols_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size351 = 0;
            $_etype354 = 0;
            $xfer += $input->readListBegin($_etype354, $_size351);
            for ($_i355 = 0; $_i355 < $_size351; ++$_i355)
            {
              $elem356 = null;
              $elem356 = new \metastore\BusiTypeColumn();
              $xfer += $elem356->read($input);
              $this->success []= $elem356;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_busi_type_cols_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter357)
          {
            $xfer += $iter357->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_busi_type_datacenters_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_busi_type_datacenters_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_busi_type_datacenters_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_busi_type_datacenters_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\BusiTypeDatacenter',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_busi_type_datacenters_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size358 = 0;
            $_etype361 = 0;
            $xfer += $input->readListBegin($_etype361, $_size358);
            for ($_i362 = 0; $_i362 < $_size358; ++$_i362)
            {
              $elem363 = null;
              $elem363 = new \metastore\BusiTypeDatacenter();
              $xfer += $elem363->read($input);
              $this->success []= $elem363;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_busi_type_datacenters_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter364)
          {
            $xfer += $iter364->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_busi_type_datacenter_args {
  static $_TSPEC;

  public $busiTypeDatacenter = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'busiTypeDatacenter',
          'type' => TType::STRUCT,
          'class' => '\metastore\BusiTypeDatacenter',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['busiTypeDatacenter'])) {
        $this->busiTypeDatacenter = $vals['busiTypeDatacenter'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_busi_type_datacenter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->busiTypeDatacenter = new \metastore\BusiTypeDatacenter();
            $xfer += $this->busiTypeDatacenter->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_busi_type_datacenter_args');
    if ($this->busiTypeDatacenter !== null) {
      if (!is_object($this->busiTypeDatacenter)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('busiTypeDatacenter', TType::STRUCT, 1);
      $xfer += $this->busiTypeDatacenter->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_busi_type_datacenter_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_busi_type_datacenter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_busi_type_datacenter_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_datawarehouse_sql_args {
  static $_TSPEC;

  public $dwNum = null;
  public $sql = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dwNum',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'sql',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dwNum'])) {
        $this->dwNum = $vals['dwNum'];
      }
      if (isset($vals['sql'])) {
        $this->sql = $vals['sql'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_datawarehouse_sql_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->dwNum);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sql);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_datawarehouse_sql_args');
    if ($this->dwNum !== null) {
      $xfer += $output->writeFieldBegin('dwNum', TType::I32, 1);
      $xfer += $output->writeI32($this->dwNum);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sql !== null) {
      $xfer += $output->writeFieldBegin('sql', TType::STRING, 2);
      $xfer += $output->writeString($this->sql);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_datawarehouse_sql_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_datawarehouse_sql_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_datawarehouse_sql_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_showBusitypes_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_showBusitypes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_showBusitypes_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_showBusitypes_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Busitype',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_showBusitypes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size365 = 0;
            $_etype368 = 0;
            $xfer += $input->readListBegin($_etype368, $_size365);
            for ($_i369 = 0; $_i369 < $_size365; ++$_i369)
            {
              $elem370 = null;
              $elem370 = new \metastore\Busitype();
              $xfer += $elem370->read($input);
              $this->success []= $elem370;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_showBusitypes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter371)
          {
            $xfer += $iter371->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_createBusitype_args {
  static $_TSPEC;

  public $busitype = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'busitype',
          'type' => TType::STRUCT,
          'class' => '\metastore\Busitype',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['busitype'])) {
        $this->busitype = $vals['busitype'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_createBusitype_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->busitype = new \metastore\Busitype();
            $xfer += $this->busitype->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_createBusitype_args');
    if ($this->busitype !== null) {
      if (!is_object($this->busitype)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('busitype', TType::STRUCT, 1);
      $xfer += $this->busitype->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_createBusitype_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_createBusitype_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_createBusitype_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_files_args {
  static $_TSPEC;

  public $part = null;
  public $files = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        2 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size372 = 0;
            $_etype375 = 0;
            $xfer += $input->readListBegin($_etype375, $_size372);
            for ($_i376 = 0; $_i376 < $_size372; ++$_i376)
            {
              $elem377 = null;
              $elem377 = new \metastore\SFile();
              $xfer += $elem377->read($input);
              $this->files []= $elem377;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_files_args');
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 1);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->files));
        {
          foreach ($this->files as $iter378)
          {
            $xfer += $iter378->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_files_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_files_args {
  static $_TSPEC;

  public $part = null;
  public $files = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        2 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size379 = 0;
            $_etype382 = 0;
            $xfer += $input->readListBegin($_etype382, $_size379);
            for ($_i383 = 0; $_i383 < $_size379; ++$_i383)
            {
              $elem384 = null;
              $elem384 = new \metastore\SFile();
              $xfer += $elem384->read($input);
              $this->files []= $elem384;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_files_args');
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 1);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->files));
        {
          foreach ($this->files as $iter385)
          {
            $xfer += $iter385->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_files_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_files_args {
  static $_TSPEC;

  public $subpart = null;
  public $files = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'subpart',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        2 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['subpart'])) {
        $this->subpart = $vals['subpart'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->subpart = new \metastore\Subpartition();
            $xfer += $this->subpart->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size386 = 0;
            $_etype389 = 0;
            $xfer += $input->readListBegin($_etype389, $_size386);
            for ($_i390 = 0; $_i390 < $_size386; ++$_i390)
            {
              $elem391 = null;
              $elem391 = new \metastore\SFile();
              $xfer += $elem391->read($input);
              $this->files []= $elem391;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_files_args');
    if ($this->subpart !== null) {
      if (!is_object($this->subpart)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subpart', TType::STRUCT, 1);
      $xfer += $this->subpart->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->files));
        {
          foreach ($this->files as $iter392)
          {
            $xfer += $iter392->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_files_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_files_args {
  static $_TSPEC;

  public $subpart = null;
  public $files = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'subpart',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        2 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['subpart'])) {
        $this->subpart = $vals['subpart'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->subpart = new \metastore\Subpartition();
            $xfer += $this->subpart->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size393 = 0;
            $_etype396 = 0;
            $xfer += $input->readListBegin($_etype396, $_size393);
            for ($_i397 = 0; $_i397 < $_size393; ++$_i397)
            {
              $elem398 = null;
              $elem398 = new \metastore\SFile();
              $xfer += $elem398->read($input);
              $this->files []= $elem398;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_files_args');
    if ($this->subpart !== null) {
      if (!is_object($this->subpart)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subpart', TType::STRUCT, 1);
      $xfer += $this->subpart->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->files));
        {
          foreach ($this->files as $iter399)
          {
            $xfer += $iter399->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_files_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_index_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_index_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_index_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_index_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_index_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_index_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_index_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_index_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_index_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Subpartition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_index_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_index_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_index_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_index_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Subpartition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_index_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_index_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_index_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $sub_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'sub_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['sub_part'])) {
        $this->sub_part = $vals['sub_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size400 = 0;
            $_etype403 = 0;
            $xfer += $input->readListBegin($_etype403, $_size400);
            for ($_i404 = 0; $_i404 < $_size400; ++$_i404)
            {
              $elem405 = null;
              $xfer += $input->readString($elem405);
              $this->part_vals []= $elem405;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->sub_part = new \metastore\Subpartition();
            $xfer += $this->sub_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter406)
          {
            $xfer += $output->writeString($iter406);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sub_part !== null) {
      if (!is_object($this->sub_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sub_part', TType::STRUCT, 4);
      $xfer += $this->sub_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_subpartitions_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_name = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_subpartitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_subpartitions_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 3);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_subpartitions_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Subpartition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_subpartitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size407 = 0;
            $_etype410 = 0;
            $xfer += $input->readListBegin($_etype410, $_size407);
            for ($_i411 = 0; $_i411 < $_size407; ++$_i411)
            {
              $elem412 = null;
              $elem412 = new \metastore\Subpartition();
              $xfer += $elem412->read($input);
              $this->success []= $elem412;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_subpartitions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter413)
          {
            $xfer += $iter413->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;
  public $file = null;
  public $originfid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        3 => array(
          'var' => 'file',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        4 => array(
          'var' => 'originfid',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
      if (isset($vals['originfid'])) {
        $this->originfid = $vals['originfid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->file = array();
            $_size414 = 0;
            $_etype417 = 0;
            $xfer += $input->readListBegin($_etype417, $_size414);
            for ($_i418 = 0; $_i418 < $_size414; ++$_i418)
            {
              $elem419 = null;
              $elem419 = new \metastore\SFile();
              $xfer += $elem419->read($input);
              $this->file []= $elem419;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->originfid = array();
            $_size420 = 0;
            $_etype423 = 0;
            $xfer += $input->readListBegin($_etype423, $_size420);
            for ($_i424 = 0; $_i424 < $_size420; ++$_i424)
            {
              $elem425 = null;
              $xfer += $input->readI64($elem425);
              $this->originfid []= $elem425;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->file !== null) {
      if (!is_array($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->file));
        {
          foreach ($this->file as $iter426)
          {
            $xfer += $iter426->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->originfid !== null) {
      if (!is_array($this->originfid)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('originfid', TType::LST, 4);
      {
        $output->writeListBegin(TType::I64, count($this->originfid));
        {
          foreach ($this->originfid as $iter427)
          {
            $xfer += $output->writeI64($iter427);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_index_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileRef',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size428 = 0;
            $_etype431 = 0;
            $xfer += $input->readListBegin($_etype431, $_size428);
            for ($_i432 = 0; $_i432 < $_size428; ++$_i432)
            {
              $elem433 = null;
              $elem433 = new \metastore\SFileRef();
              $xfer += $elem433->read($input);
              $this->success []= $elem433;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_index_files_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter434)
          {
            $xfer += $iter434->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $part = null;
  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        3 => array(
          'var' => 'file',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['part'])) {
        $this->part = $vals['part'];
      }
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->part = new \metastore\Partition();
            $xfer += $this->part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->file = array();
            $_size435 = 0;
            $_etype438 = 0;
            $xfer += $input->readListBegin($_etype438, $_size435);
            for ($_i439 = 0; $_i439 < $_size435; ++$_i439)
            {
              $elem440 = null;
              $elem440 = new \metastore\SFile();
              $xfer += $elem440->read($input);
              $this->file []= $elem440;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part !== null) {
      if (!is_object($this->part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part', TType::STRUCT, 2);
      $xfer += $this->part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->file !== null) {
      if (!is_array($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->file));
        {
          foreach ($this->file as $iter441)
          {
            $xfer += $iter441->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_index_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $subpart = null;
  public $file = null;
  public $originfid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'subpart',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        3 => array(
          'var' => 'file',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        4 => array(
          'var' => 'originfid',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['subpart'])) {
        $this->subpart = $vals['subpart'];
      }
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
      if (isset($vals['originfid'])) {
        $this->originfid = $vals['originfid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->subpart = new \metastore\Subpartition();
            $xfer += $this->subpart->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->file = array();
            $_size442 = 0;
            $_etype445 = 0;
            $xfer += $input->readListBegin($_etype445, $_size442);
            for ($_i446 = 0; $_i446 < $_size442; ++$_i446)
            {
              $elem447 = null;
              $elem447 = new \metastore\SFile();
              $xfer += $elem447->read($input);
              $this->file []= $elem447;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->originfid = array();
            $_size448 = 0;
            $_etype451 = 0;
            $xfer += $input->readListBegin($_etype451, $_size448);
            for ($_i452 = 0; $_i452 < $_size448; ++$_i452)
            {
              $elem453 = null;
              $xfer += $input->readI64($elem453);
              $this->originfid []= $elem453;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subpart !== null) {
      if (!is_object($this->subpart)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subpart', TType::STRUCT, 2);
      $xfer += $this->subpart->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->file !== null) {
      if (!is_array($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->file));
        {
          foreach ($this->file as $iter454)
          {
            $xfer += $iter454->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->originfid !== null) {
      if (!is_array($this->originfid)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('originfid', TType::LST, 4);
      {
        $output->writeListBegin(TType::I64, count($this->originfid));
        {
          foreach ($this->originfid as $iter455)
          {
            $xfer += $output->writeI64($iter455);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_subpartition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_subpartition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_subpartition_index_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_subpartition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $subpart = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'subpart',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['subpart'])) {
        $this->subpart = $vals['subpart'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_subpartition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->subpart = new \metastore\Subpartition();
            $xfer += $this->subpart->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_subpartition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subpart !== null) {
      if (!is_object($this->subpart)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subpart', TType::STRUCT, 2);
      $xfer += $this->subpart->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_subpartition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileRef',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_subpartition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size456 = 0;
            $_etype459 = 0;
            $xfer += $input->readListBegin($_etype459, $_size456);
            for ($_i460 = 0; $_i460 < $_size456; ++$_i460)
            {
              $elem461 = null;
              $elem461 = new \metastore\SFileRef();
              $xfer += $elem461->read($input);
              $this->success []= $elem461;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_subpartition_index_files_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter462)
          {
            $xfer += $iter462->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_index_files_args {
  static $_TSPEC;

  public $index = null;
  public $subpart = null;
  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'subpart',
          'type' => TType::STRUCT,
          'class' => '\metastore\Subpartition',
          ),
        3 => array(
          'var' => 'file',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['index'])) {
        $this->index = $vals['index'];
      }
      if (isset($vals['subpart'])) {
        $this->subpart = $vals['subpart'];
      }
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_index_files_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->index = new \metastore\Index();
            $xfer += $this->index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->subpart = new \metastore\Subpartition();
            $xfer += $this->subpart->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->file = array();
            $_size463 = 0;
            $_etype466 = 0;
            $xfer += $input->readListBegin($_etype466, $_size463);
            for ($_i467 = 0; $_i467 < $_size463; ++$_i467)
            {
              $elem468 = null;
              $elem468 = new \metastore\SFile();
              $xfer += $elem468->read($input);
              $this->file []= $elem468;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_index_files_args');
    if ($this->index !== null) {
      if (!is_object($this->index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index', TType::STRUCT, 1);
      $xfer += $this->index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subpart !== null) {
      if (!is_object($this->subpart)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subpart', TType::STRUCT, 2);
      $xfer += $this->subpart->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->file !== null) {
      if (!is_array($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->file));
        {
          foreach ($this->file as $iter469)
          {
            $xfer += $iter469->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_subpartition_index_files_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_subpartition_index_files_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_subpartition_index_files_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addGeoLocation_args {
  static $_TSPEC;

  public $gl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'gl',
          'type' => TType::STRUCT,
          'class' => '\metastore\GeoLocation',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['gl'])) {
        $this->gl = $vals['gl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addGeoLocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->gl = new \metastore\GeoLocation();
            $xfer += $this->gl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addGeoLocation_args');
    if ($this->gl !== null) {
      if (!is_object($this->gl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('gl', TType::STRUCT, 1);
      $xfer += $this->gl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addGeoLocation_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addGeoLocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addGeoLocation_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyGeoLocation_args {
  static $_TSPEC;

  public $gl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'gl',
          'type' => TType::STRUCT,
          'class' => '\metastore\GeoLocation',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['gl'])) {
        $this->gl = $vals['gl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyGeoLocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->gl = new \metastore\GeoLocation();
            $xfer += $this->gl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyGeoLocation_args');
    if ($this->gl !== null) {
      if (!is_object($this->gl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('gl', TType::STRUCT, 1);
      $xfer += $this->gl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyGeoLocation_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyGeoLocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyGeoLocation_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteGeoLocation_args {
  static $_TSPEC;

  public $gl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'gl',
          'type' => TType::STRUCT,
          'class' => '\metastore\GeoLocation',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['gl'])) {
        $this->gl = $vals['gl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteGeoLocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->gl = new \metastore\GeoLocation();
            $xfer += $this->gl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteGeoLocation_args');
    if ($this->gl !== null) {
      if (!is_object($this->gl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('gl', TType::STRUCT, 1);
      $xfer += $this->gl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteGeoLocation_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteGeoLocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteGeoLocation_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listGeoLocation_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listGeoLocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listGeoLocation_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listGeoLocation_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\GeoLocation',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listGeoLocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size470 = 0;
            $_etype473 = 0;
            $xfer += $input->readListBegin($_etype473, $_size470);
            for ($_i474 = 0; $_i474 < $_size470; ++$_i474)
            {
              $elem475 = null;
              $elem475 = new \metastore\GeoLocation();
              $xfer += $elem475->read($input);
              $this->success []= $elem475;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listGeoLocation_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter476)
          {
            $xfer += $iter476->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addEquipRoom_args {
  static $_TSPEC;

  public $er = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'er',
          'type' => TType::STRUCT,
          'class' => '\metastore\EquipRoom',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['er'])) {
        $this->er = $vals['er'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addEquipRoom_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->er = new \metastore\EquipRoom();
            $xfer += $this->er->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addEquipRoom_args');
    if ($this->er !== null) {
      if (!is_object($this->er)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('er', TType::STRUCT, 1);
      $xfer += $this->er->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addEquipRoom_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addEquipRoom_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addEquipRoom_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyEquipRoom_args {
  static $_TSPEC;

  public $er = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'er',
          'type' => TType::STRUCT,
          'class' => '\metastore\EquipRoom',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['er'])) {
        $this->er = $vals['er'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyEquipRoom_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->er = new \metastore\EquipRoom();
            $xfer += $this->er->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyEquipRoom_args');
    if ($this->er !== null) {
      if (!is_object($this->er)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('er', TType::STRUCT, 1);
      $xfer += $this->er->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyEquipRoom_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyEquipRoom_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyEquipRoom_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteEquipRoom_args {
  static $_TSPEC;

  public $er = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'er',
          'type' => TType::STRUCT,
          'class' => '\metastore\EquipRoom',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['er'])) {
        $this->er = $vals['er'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteEquipRoom_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->er = new \metastore\EquipRoom();
            $xfer += $this->er->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteEquipRoom_args');
    if ($this->er !== null) {
      if (!is_object($this->er)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('er', TType::STRUCT, 1);
      $xfer += $this->er->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteEquipRoom_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteEquipRoom_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteEquipRoom_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listEquipRoom_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listEquipRoom_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listEquipRoom_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listEquipRoom_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\EquipRoom',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listEquipRoom_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size477 = 0;
            $_etype480 = 0;
            $xfer += $input->readListBegin($_etype480, $_size477);
            for ($_i481 = 0; $_i481 < $_size477; ++$_i481)
            {
              $elem482 = null;
              $elem482 = new \metastore\EquipRoom();
              $xfer += $elem482->read($input);
              $this->success []= $elem482;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listEquipRoom_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter483)
          {
            $xfer += $iter483->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getGeoLocationByName_args {
  static $_TSPEC;

  public $geoLocName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'geoLocName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['geoLocName'])) {
        $this->geoLocName = $vals['geoLocName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getGeoLocationByName_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->geoLocName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getGeoLocationByName_args');
    if ($this->geoLocName !== null) {
      $xfer += $output->writeFieldBegin('geoLocName', TType::STRING, 1);
      $xfer += $output->writeString($this->geoLocName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getGeoLocationByName_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GeoLocation',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getGeoLocationByName_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GeoLocation();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getGeoLocationByName_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getGeoLocationByNames_args {
  static $_TSPEC;

  public $geoLocNames = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'geoLocNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['geoLocNames'])) {
        $this->geoLocNames = $vals['geoLocNames'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getGeoLocationByNames_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->geoLocNames = array();
            $_size484 = 0;
            $_etype487 = 0;
            $xfer += $input->readListBegin($_etype487, $_size484);
            for ($_i488 = 0; $_i488 < $_size484; ++$_i488)
            {
              $elem489 = null;
              $xfer += $input->readString($elem489);
              $this->geoLocNames []= $elem489;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getGeoLocationByNames_args');
    if ($this->geoLocNames !== null) {
      if (!is_array($this->geoLocNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('geoLocNames', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->geoLocNames));
        {
          foreach ($this->geoLocNames as $iter490)
          {
            $xfer += $output->writeString($iter490);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getGeoLocationByNames_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\GeoLocation',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getGeoLocationByNames_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size491 = 0;
            $_etype494 = 0;
            $xfer += $input->readListBegin($_etype494, $_size491);
            for ($_i495 = 0; $_i495 < $_size491; ++$_i495)
            {
              $elem496 = null;
              $elem496 = new \metastore\GeoLocation();
              $xfer += $elem496->read($input);
              $this->success []= $elem496;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getGeoLocationByNames_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter497)
          {
            $xfer += $iter497->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeAssignment_args {
  static $_TSPEC;

  public $nodeName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nodeName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nodeName'])) {
        $this->nodeName = $vals['nodeName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nodeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeAssignment_args');
    if ($this->nodeName !== null) {
      $xfer += $output->writeFieldBegin('nodeName', TType::STRING, 1);
      $xfer += $output->writeString($this->nodeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeAssignment_args {
  static $_TSPEC;

  public $nodeName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nodeName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nodeName'])) {
        $this->nodeName = $vals['nodeName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nodeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeAssignment_args');
    if ($this->nodeName !== null) {
      $xfer += $output->writeFieldBegin('nodeName', TType::STRING, 1);
      $xfer += $output->writeString($this->nodeName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodes_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodes_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodes_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Node',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size498 = 0;
            $_etype501 = 0;
            $xfer += $input->readListBegin($_etype501, $_size498);
            for ($_i502 = 0; $_i502 < $_size498; ++$_i502)
            {
              $elem503 = null;
              $elem503 = new \metastore\Node();
              $xfer += $elem503->read($input);
              $this->success []= $elem503;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter504)
          {
            $xfer += $iter504->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addUserAssignment_args {
  static $_TSPEC;

  public $roleName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addUserAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addUserAssignment_args');
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addUserAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addUserAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addUserAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteUserAssignment_args {
  static $_TSPEC;

  public $roleName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roleName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roleName'])) {
        $this->roleName = $vals['roleName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteUserAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->roleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteUserAssignment_args');
    if ($this->roleName !== null) {
      $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
      $xfer += $output->writeString($this->roleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteUserAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteUserAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteUserAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listUsers_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listUsers_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listUsers_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listUsers_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\User',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listUsers_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size505 = 0;
            $_etype508 = 0;
            $xfer += $input->readListBegin($_etype508, $_size505);
            for ($_i509 = 0; $_i509 < $_size505; ++$_i509)
            {
              $elem510 = null;
              $elem510 = new \metastore\User();
              $xfer += $elem510->read($input);
              $this->success []= $elem510;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listUsers_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter511)
          {
            $xfer += $iter511->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addRoleAssignment_args {
  static $_TSPEC;

  public $userName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userName'])) {
        $this->userName = $vals['userName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addRoleAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->userName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addRoleAssignment_args');
    if ($this->userName !== null) {
      $xfer += $output->writeFieldBegin('userName', TType::STRING, 1);
      $xfer += $output->writeString($this->userName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addRoleAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addRoleAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addRoleAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteRoleAssignment_args {
  static $_TSPEC;

  public $userName = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userName'])) {
        $this->userName = $vals['userName'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteRoleAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->userName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteRoleAssignment_args');
    if ($this->userName !== null) {
      $xfer += $output->writeFieldBegin('userName', TType::STRING, 1);
      $xfer += $output->writeString($this->userName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteRoleAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteRoleAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteRoleAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listRoles_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listRoles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listRoles_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listRoles_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Role',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listRoles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size512 = 0;
            $_etype515 = 0;
            $xfer += $input->readListBegin($_etype515, $_size512);
            for ($_i516 = 0; $_i516 < $_size512; ++$_i516)
            {
              $elem517 = null;
              $elem517 = new \metastore\Role();
              $xfer += $elem517->read($input);
              $this->success []= $elem517;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listRoles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter518)
          {
            $xfer += $iter518->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeGroupAssignment_args {
  static $_TSPEC;

  public $ng = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ng',
          'type' => TType::STRUCT,
          'class' => '\metastore\NodeGroup',
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeGroupAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ng = new \metastore\NodeGroup();
            $xfer += $this->ng->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeGroupAssignment_args');
    if ($this->ng !== null) {
      if (!is_object($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::STRUCT, 1);
      $xfer += $this->ng->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeGroupAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeGroupAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeGroupAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeGroupAssignment_args {
  static $_TSPEC;

  public $ng = null;
  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ng',
          'type' => TType::STRUCT,
          'class' => '\metastore\NodeGroup',
          ),
        2 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeGroupAssignment_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ng = new \metastore\NodeGroup();
            $xfer += $this->ng->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeGroupAssignment_args');
    if ($this->ng !== null) {
      if (!is_object($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::STRUCT, 1);
      $xfer += $this->ng->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeGroupAssignment_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeGroupAssignment_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeGroupAssignment_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_pingPong_args {
  static $_TSPEC;

  public $str = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'str',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['str'])) {
        $this->str = $vals['str'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_pingPong_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->str);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_pingPong_args');
    if ($this->str !== null) {
      $xfer += $output->writeFieldBegin('str', TType::STRING, 1);
      $xfer += $output->writeString($this->str);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_pingPong_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_pingPong_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_pingPong_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_database_args {
  static $_TSPEC;

  public $database = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'database',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['database'])) {
        $this->database = $vals['database'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->database = new \metastore\Database();
            $xfer += $this->database->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_args');
    if ($this->database !== null) {
      if (!is_object($this->database)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('database', TType::STRUCT, 1);
      $xfer += $this->database->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_database_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_database_args {
  static $_TSPEC;

  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_database_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Database();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_database_args {
  static $_TSPEC;

  public $name = null;
  public $deleteData = null;
  public $cascade = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'cascade',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
      if (isset($vals['cascade'])) {
        $this->cascade = $vals['cascade'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->cascade);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cascade !== null) {
      $xfer += $output->writeFieldBegin('cascade', TType::BOOL, 3);
      $xfer += $output->writeBool($this->cascade);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_database_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_databases_args {
  static $_TSPEC;

  public $pattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_databases_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_args');
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 1);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_databases_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_databases_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size519 = 0;
            $_etype522 = 0;
            $xfer += $input->readListBegin($_etype522, $_size519);
            for ($_i523 = 0; $_i523 < $_size519; ++$_i523)
            {
              $elem524 = null;
              $xfer += $input->readString($elem524);
              $this->success []= $elem524;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter525)
          {
            $xfer += $output->writeString($iter525);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_databases_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_databases_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_databases_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_databases_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size526 = 0;
            $_etype529 = 0;
            $xfer += $input->readListBegin($_etype529, $_size526);
            for ($_i530 = 0; $_i530 < $_size526; ++$_i530)
            {
              $elem531 = null;
              $xfer += $input->readString($elem531);
              $this->success []= $elem531;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter532)
          {
            $xfer += $output->writeString($iter532);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_database_args {
  static $_TSPEC;

  public $dbname = null;
  public $db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'db',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_database_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->db = new \metastore\Database();
            $xfer += $this->db->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db !== null) {
      if (!is_object($this->db)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('db', TType::STRUCT, 2);
      $xfer += $this->db->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_database_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_database_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_args {
  static $_TSPEC;

  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Type',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Type();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_type_args {
  static $_TSPEC;

  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRUCT,
          'class' => '\metastore\Type',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->type = new \metastore\Type();
            $xfer += $this->type->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_args');
    if ($this->type !== null) {
      if (!is_object($this->type)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('type', TType::STRUCT, 1);
      $xfer += $this->type->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_type_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_type_args {
  static $_TSPEC;

  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_type_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_args');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_type_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_type_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_all_args {
  static $_TSPEC;

  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_all_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_type_all_result {
  static $_TSPEC;

  public $success = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Type',
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_type_all_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size533 = 0;
            $_ktype534 = 0;
            $_vtype535 = 0;
            $xfer += $input->readMapBegin($_ktype534, $_vtype535, $_size533);
            for ($_i537 = 0; $_i537 < $_size533; ++$_i537)
            {
              $key538 = '';
              $val539 = new \metastore\Type();
              $xfer += $input->readString($key538);
              $val539 = new \metastore\Type();
              $xfer += $val539->read($input);
              $this->success[$key538] = $val539;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $kiter540 => $viter541)
          {
            $xfer += $output->writeString($kiter540);
            $xfer += $viter541->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_args {
  static $_TSPEC;

  public $db_name = null;
  public $table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_fields_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_fields_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size542 = 0;
            $_etype545 = 0;
            $xfer += $input->readListBegin($_etype545, $_size542);
            for ($_i546 = 0; $_i546 < $_size542; ++$_i546)
            {
              $elem547 = null;
              $elem547 = new \metastore\FieldSchema();
              $xfer += $elem547->read($input);
              $this->success []= $elem547;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter548)
          {
            $xfer += $iter548->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_args {
  static $_TSPEC;

  public $db_name = null;
  public $table_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_schema_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_schema_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size549 = 0;
            $_etype552 = 0;
            $xfer += $input->readListBegin($_etype552, $_size549);
            for ($_i553 = 0; $_i553 < $_size549; ++$_i553)
            {
              $elem554 = null;
              $elem554 = new \metastore\FieldSchema();
              $xfer += $elem554->read($input);
              $this->success []= $elem554;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\UnknownTableException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter555)
          {
            $xfer += $iter555->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_args {
  static $_TSPEC;

  public $tbl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_by_user_args {
  static $_TSPEC;

  public $tbl = null;
  public $user = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'user',
          'type' => TType::STRUCT,
          'class' => '\metastore\User',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_by_user_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->user = new \metastore\User();
            $xfer += $this->user->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_by_user_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user !== null) {
      if (!is_object($this->user)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('user', TType::STRUCT, 2);
      $xfer += $this->user->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_by_user_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_by_user_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_by_user_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_environment_context_args {
  static $_TSPEC;

  public $tbl = null;
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_table_with_environment_context_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_table_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\NoSuchObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_args {
  static $_TSPEC;

  public $dbname = null;
  public $name = null;
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_table_result {
  static $_TSPEC;

  public $o1 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_args {
  static $_TSPEC;

  public $db_name = null;
  public $pattern = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pattern',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['pattern'])) {
        $this->pattern = $vals['pattern'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->pattern);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pattern !== null) {
      $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
      $xfer += $output->writeString($this->pattern);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_tables_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_tables_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size556 = 0;
            $_etype559 = 0;
            $xfer += $input->readListBegin($_etype559, $_size556);
            for ($_i560 = 0; $_i560 < $_size556; ++$_i560)
            {
              $elem561 = null;
              $xfer += $input->readString($elem561);
              $this->success []= $elem561;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter562)
          {
            $xfer += $output->writeString($iter562);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_tables_args {
  static $_TSPEC;

  public $db_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_tables_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_tables_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_tables_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size563 = 0;
            $_etype566 = 0;
            $xfer += $input->readListBegin($_etype566, $_size563);
            for ($_i567 = 0; $_i567 < $_size563; ++$_i567)
            {
              $elem568 = null;
              $xfer += $input->readString($elem568);
              $this->success []= $elem568;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter569)
          {
            $xfer += $output->writeString($iter569);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Table();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_names'])) {
        $this->tbl_names = $vals['tbl_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->tbl_names = array();
            $_size570 = 0;
            $_etype573 = 0;
            $xfer += $input->readListBegin($_etype573, $_size570);
            for ($_i574 = 0; $_i574 < $_size570; ++$_i574)
            {
              $elem575 = null;
              $xfer += $input->readString($elem575);
              $this->tbl_names []= $elem575;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_names !== null) {
      if (!is_array($this->tbl_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl_names', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->tbl_names));
        {
          foreach ($this->tbl_names as $iter576)
          {
            $xfer += $output->writeString($iter576);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_objects_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Table',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_objects_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size577 = 0;
            $_etype580 = 0;
            $xfer += $input->readListBegin($_etype580, $_size577);
            for ($_i581 = 0; $_i581 < $_size577; ++$_i581)
            {
              $elem582 = null;
              $elem582 = new \metastore\Table();
              $xfer += $elem582->read($input);
              $this->success []= $elem582;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_objects_by_name_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter583)
          {
            $xfer += $iter583->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_names_by_filter_args {
  static $_TSPEC;

  public $dbname = null;
  public $filter = null;
  public $max_tables = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_tables',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['max_tables'])) {
        $this->max_tables = $vals['max_tables'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_names_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_tables);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_tables !== null) {
      $xfer += $output->writeFieldBegin('max_tables', TType::I16, 3);
      $xfer += $output->writeI16($this->max_tables);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_names_by_filter_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_names_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size584 = 0;
            $_etype587 = 0;
            $xfer += $input->readListBegin($_etype587, $_size584);
            for ($_i588 = 0; $_i588 < $_size584; ++$_i588)
            {
              $elem589 = null;
              $xfer += $input->readString($elem589);
              $this->success []= $elem589;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidOperationException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_names_by_filter_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter590)
          {
            $xfer += $output->writeString($iter590);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_name = null;
  public $new_tbl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_tbl'])) {
        $this->new_tbl = $vals['new_tbl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_tbl = new \metastore\Table();
            $xfer += $this->new_tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_tbl !== null) {
      if (!is_object($this->new_tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
      $xfer += $this->new_tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_environment_context_args {
  static $_TSPEC;

  public $dbname = null;
  public $tbl_name = null;
  public $new_tbl = null;
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_tbl'])) {
        $this->new_tbl = $vals['new_tbl'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_tbl = new \metastore\Table();
            $xfer += $this->new_tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_tbl !== null) {
      if (!is_object($this->new_tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
      $xfer += $this->new_tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_table_with_environment_context_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_table_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_args {
  static $_TSPEC;

  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_args');
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_with_environment_context_args {
  static $_TSPEC;

  public $new_part = null;
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        2 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_args');
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 2);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partition_with_environment_context_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_with_environment_context_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_args {
  static $_TSPEC;

  public $new_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size591 = 0;
            $_etype594 = 0;
            $xfer += $input->readListBegin($_etype594, $_size591);
            for ($_i595 = 0; $_i595 < $_size591; ++$_i595)
            {
              $elem596 = null;
              $elem596 = new \metastore\Partition();
              $xfer += $elem596->read($input);
              $this->new_parts []= $elem596;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_args');
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter597)
          {
            $xfer += $iter597->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_partitions_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partitions_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size598 = 0;
            $_etype601 = 0;
            $xfer += $input->readListBegin($_etype601, $_size598);
            for ($_i602 = 0; $_i602 < $_size598; ++$_i602)
            {
              $elem603 = null;
              $xfer += $input->readString($elem603);
              $this->part_vals []= $elem603;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter604)
          {
            $xfer += $output->writeString($iter604);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_append_partition_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_append_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size605 = 0;
            $_etype608 = 0;
            $xfer += $input->readListBegin($_etype608, $_size605);
            for ($_i609 = 0; $_i609 < $_size605; ++$_i609)
            {
              $elem610 = null;
              $xfer += $input->readString($elem610);
              $this->part_vals []= $elem610;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter611)
          {
            $xfer += $output->writeString($iter611);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_name = null;
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_partition_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size612 = 0;
            $_etype615 = 0;
            $xfer += $input->readListBegin($_etype615, $_size612);
            for ($_i616 = 0; $_i616 < $_size612; ++$_i616)
            {
              $elem617 = null;
              $xfer += $input->readString($elem617);
              $this->part_vals []= $elem617;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter618)
          {
            $xfer += $output->writeString($iter618);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_with_auth_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $user_name = null;
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size619 = 0;
            $_etype622 = 0;
            $xfer += $input->readListBegin($_etype622, $_size619);
            for ($_i623 = 0; $_i623 < $_size619; ++$_i623)
            {
              $elem624 = null;
              $xfer += $input->readString($elem624);
              $this->part_vals []= $elem624;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size625 = 0;
            $_etype628 = 0;
            $xfer += $input->readListBegin($_etype628, $_size625);
            for ($_i629 = 0; $_i629 < $_size625; ++$_i629)
            {
              $elem630 = null;
              $xfer += $input->readString($elem630);
              $this->group_names []= $elem630;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter631)
          {
            $xfer += $output->writeString($iter631);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter632)
          {
            $xfer += $output->writeString($iter632);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_with_auth_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_by_name_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Partition();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size633 = 0;
            $_etype636 = 0;
            $xfer += $input->readListBegin($_etype636, $_size633);
            for ($_i637 = 0; $_i637 < $_size633; ++$_i637)
            {
              $elem638 = null;
              $elem638 = new \metastore\Partition();
              $xfer += $elem638->read($input);
              $this->success []= $elem638;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter639)
          {
            $xfer += $iter639->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_with_auth_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_parts = -1;
  public $user_name = null;
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        4 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size640 = 0;
            $_etype643 = 0;
            $xfer += $input->readListBegin($_etype643, $_size640);
            for ($_i644 = 0; $_i644 < $_size640; ++$_i644)
            {
              $elem645 = null;
              $xfer += $input->readString($elem645);
              $this->group_names []= $elem645;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter646)
          {
            $xfer += $output->writeString($iter646);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_with_auth_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size647 = 0;
            $_etype650 = 0;
            $xfer += $input->readListBegin($_etype650, $_size647);
            for ($_i651 = 0; $_i651 < $_size647; ++$_i651)
            {
              $elem652 = null;
              $elem652 = new \metastore\Partition();
              $xfer += $elem652->read($input);
              $this->success []= $elem652;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter653)
          {
            $xfer += $iter653->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_result {
  static $_TSPEC;

  public $success = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size654 = 0;
            $_etype657 = 0;
            $xfer += $input->readListBegin($_etype657, $_size654);
            for ($_i658 = 0; $_i658 < $_size654; ++$_i658)
            {
              $elem659 = null;
              $xfer += $input->readString($elem659);
              $this->success []= $elem659;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter660)
          {
            $xfer += $output->writeString($iter660);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size661 = 0;
            $_etype664 = 0;
            $xfer += $input->readListBegin($_etype664, $_size661);
            for ($_i665 = 0; $_i665 < $_size661; ++$_i665)
            {
              $elem666 = null;
              $xfer += $input->readString($elem666);
              $this->part_vals []= $elem666;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter667)
          {
            $xfer += $output->writeString($iter667);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size668 = 0;
            $_etype671 = 0;
            $xfer += $input->readListBegin($_etype671, $_size668);
            for ($_i672 = 0; $_i672 < $_size668; ++$_i672)
            {
              $elem673 = null;
              $elem673 = new \metastore\Partition();
              $xfer += $elem673->read($input);
              $this->success []= $elem673;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter674)
          {
            $xfer += $iter674->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_with_auth_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $max_parts = -1;
  public $user_name = null;
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_with_auth_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size675 = 0;
            $_etype678 = 0;
            $xfer += $input->readListBegin($_etype678, $_size675);
            for ($_i679 = 0; $_i679 < $_size675; ++$_i679)
            {
              $elem680 = null;
              $xfer += $input->readString($elem680);
              $this->part_vals []= $elem680;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size681 = 0;
            $_etype684 = 0;
            $xfer += $input->readListBegin($_etype684, $_size681);
            for ($_i685 = 0; $_i685 < $_size681; ++$_i685)
            {
              $elem686 = null;
              $xfer += $input->readString($elem686);
              $this->group_names []= $elem686;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter687)
          {
            $xfer += $output->writeString($iter687);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 5);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter688)
          {
            $xfer += $output->writeString($iter688);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_ps_with_auth_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_ps_with_auth_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size689 = 0;
            $_etype692 = 0;
            $xfer += $input->readListBegin($_etype692, $_size689);
            for ($_i693 = 0; $_i693 < $_size689; ++$_i693)
            {
              $elem694 = null;
              $elem694 = new \metastore\Partition();
              $xfer += $elem694->read($input);
              $this->success []= $elem694;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter695)
          {
            $xfer += $iter695->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_ps_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_ps_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size696 = 0;
            $_etype699 = 0;
            $xfer += $input->readListBegin($_etype699, $_size696);
            for ($_i700 = 0; $_i700 < $_size696; ++$_i700)
            {
              $elem701 = null;
              $xfer += $input->readString($elem701);
              $this->part_vals []= $elem701;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter702)
          {
            $xfer += $output->writeString($iter702);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_names_ps_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_names_ps_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size703 = 0;
            $_etype706 = 0;
            $xfer += $input->readListBegin($_etype706, $_size703);
            for ($_i707 = 0; $_i707 < $_size703; ++$_i707)
            {
              $elem708 = null;
              $xfer += $input->readString($elem708);
              $this->success []= $elem708;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter709)
          {
            $xfer += $output->writeString($iter709);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_filter_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $filter = null;
  public $max_parts = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'filter',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'max_parts',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['filter'])) {
        $this->filter = $vals['filter'];
      }
      if (isset($vals['max_parts'])) {
        $this->max_parts = $vals['max_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_filter_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_parts);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filter !== null) {
      $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
      $xfer += $output->writeString($this->filter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_parts !== null) {
      $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
      $xfer += $output->writeI16($this->max_parts);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_filter_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_filter_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size710 = 0;
            $_etype713 = 0;
            $xfer += $input->readListBegin($_etype713, $_size710);
            for ($_i714 = 0; $_i714 < $_size710; ++$_i714)
            {
              $elem715 = null;
              $elem715 = new \metastore\Partition();
              $xfer += $elem715->read($input);
              $this->success []= $elem715;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter716)
          {
            $xfer += $iter716->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_names_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['names'])) {
        $this->names = $vals['names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->names = array();
            $_size717 = 0;
            $_etype720 = 0;
            $xfer += $input->readListBegin($_etype720, $_size717);
            for ($_i721 = 0; $_i721 < $_size717; ++$_i721)
            {
              $elem722 = null;
              $xfer += $input->readString($elem722);
              $this->names []= $elem722;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->names !== null) {
      if (!is_array($this->names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('names', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->names));
        {
          foreach ($this->names as $iter723)
          {
            $xfer += $output->writeString($iter723);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partitions_by_names_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partitions_by_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size724 = 0;
            $_etype727 = 0;
            $xfer += $input->readListBegin($_etype727, $_size724);
            for ($_i728 = 0; $_i728 < $_size724; ++$_i728)
            {
              $elem729 = null;
              $elem729 = new \metastore\Partition();
              $xfer += $elem729->read($input);
              $this->success []= $elem729;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter730)
          {
            $xfer += $iter730->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $new_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_parts'])) {
        $this->new_parts = $vals['new_parts'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->new_parts = array();
            $_size731 = 0;
            $_etype734 = 0;
            $xfer += $input->readListBegin($_etype734, $_size731);
            for ($_i735 = 0; $_i735 < $_size731; ++$_i735)
            {
              $elem736 = null;
              $elem736 = new \metastore\Partition();
              $xfer += $elem736->read($input);
              $this->new_parts []= $elem736;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_parts !== null) {
      if (!is_array($this->new_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_parts', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->new_parts));
        {
          foreach ($this->new_parts as $iter737)
          {
            $xfer += $iter737->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partitions_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partitions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partitions_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_with_environment_context_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $new_part = null;
  public $environment_context = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        4 => array(
          'var' => 'environment_context',
          'type' => TType::STRUCT,
          'class' => '\metastore\EnvironmentContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
      if (isset($vals['environment_context'])) {
        $this->environment_context = $vals['environment_context'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_with_environment_context_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->environment_context = new \metastore\EnvironmentContext();
            $xfer += $this->environment_context->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->environment_context !== null) {
      if (!is_object($this->environment_context)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('environment_context', TType::STRUCT, 4);
      $xfer += $this->environment_context->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_partition_with_environment_context_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_partition_with_environment_context_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_with_environment_context_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rename_partition_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $new_part = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'new_part',
          'type' => TType::STRUCT,
          'class' => '\metastore\Partition',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['new_part'])) {
        $this->new_part = $vals['new_part'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rename_partition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->part_vals = array();
            $_size738 = 0;
            $_etype741 = 0;
            $xfer += $input->readListBegin($_etype741, $_size738);
            for ($_i742 = 0; $_i742 < $_size738; ++$_i742)
            {
              $elem743 = null;
              $xfer += $input->readString($elem743);
              $this->part_vals []= $elem743;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->new_part = new \metastore\Partition();
            $xfer += $this->new_part->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $iter744)
          {
            $xfer += $output->writeString($iter744);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_part !== null) {
      if (!is_object($this->new_part)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 4);
      $xfer += $this->new_part->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rename_partition_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rename_partition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rename_partition_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_config_value_args {
  static $_TSPEC;

  public $name = null;
  public $defaultValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'defaultValue',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['defaultValue'])) {
        $this->defaultValue = $vals['defaultValue'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_config_value_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->defaultValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultValue !== null) {
      $xfer += $output->writeFieldBegin('defaultValue', TType::STRING, 2);
      $xfer += $output->writeString($this->defaultValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_config_value_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\ConfigValSecurityException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_config_value_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\ConfigValSecurityException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_vals_args {
  static $_TSPEC;

  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_vals_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_args');
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_vals_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_vals_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size745 = 0;
            $_etype748 = 0;
            $xfer += $input->readListBegin($_etype748, $_size745);
            for ($_i749 = 0; $_i749 < $_size745; ++$_i749)
            {
              $elem750 = null;
              $xfer += $input->readString($elem750);
              $this->success []= $elem750;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter751)
          {
            $xfer += $output->writeString($iter751);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_spec_args {
  static $_TSPEC;

  public $part_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_spec_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_args');
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_partition_name_to_spec_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_partition_name_to_spec_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size752 = 0;
            $_ktype753 = 0;
            $_vtype754 = 0;
            $xfer += $input->readMapBegin($_ktype753, $_vtype754, $_size752);
            for ($_i756 = 0; $_i756 < $_size752; ++$_i756)
            {
              $key757 = '';
              $val758 = '';
              $xfer += $input->readString($key757);
              $xfer += $input->readString($val758);
              $this->success[$key757] = $val758;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->success));
        {
          foreach ($this->success as $kiter759 => $viter760)
          {
            $xfer += $output->writeString($kiter759);
            $xfer += $output->writeString($viter760);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_markPartitionForEvent_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $eventType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'eventType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['eventType'])) {
        $this->eventType = $vals['eventType'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_markPartitionForEvent_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->part_vals = array();
            $_size761 = 0;
            $_ktype762 = 0;
            $_vtype763 = 0;
            $xfer += $input->readMapBegin($_ktype762, $_vtype763, $_size761);
            for ($_i765 = 0; $_i765 < $_size761; ++$_i765)
            {
              $key766 = '';
              $val767 = '';
              $xfer += $input->readString($key766);
              $xfer += $input->readString($val767);
              $this->part_vals[$key766] = $val767;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $kiter768 => $viter769)
          {
            $xfer += $output->writeString($kiter768);
            $xfer += $output->writeString($viter769);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventType !== null) {
      $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
      $xfer += $output->writeI32($this->eventType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_markPartitionForEvent_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;
  public $o5 = null;
  public $o6 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        5 => array(
          'var' => 'o5',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownPartitionException',
          ),
        6 => array(
          'var' => 'o6',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidPartitionException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
      if (isset($vals['o5'])) {
        $this->o5 = $vals['o5'];
      }
      if (isset($vals['o6'])) {
        $this->o6 = $vals['o6'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_markPartitionForEvent_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\UnknownTableException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->o5 = new \metastore\UnknownPartitionException();
            $xfer += $this->o5->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->o6 = new \metastore\InvalidPartitionException();
            $xfer += $this->o6->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_markPartitionForEvent_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o5 !== null) {
      $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
      $xfer += $this->o5->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o6 !== null) {
      $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
      $xfer += $this->o6->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_isPartitionMarkedForEvent_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_vals = null;
  public $eventType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_vals',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'eventType',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_vals'])) {
        $this->part_vals = $vals['part_vals'];
      }
      if (isset($vals['eventType'])) {
        $this->eventType = $vals['eventType'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_isPartitionMarkedForEvent_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->part_vals = array();
            $_size770 = 0;
            $_ktype771 = 0;
            $_vtype772 = 0;
            $xfer += $input->readMapBegin($_ktype771, $_vtype772, $_size770);
            for ($_i774 = 0; $_i774 < $_size770; ++$_i774)
            {
              $key775 = '';
              $val776 = '';
              $xfer += $input->readString($key775);
              $xfer += $input->readString($val776);
              $this->part_vals[$key775] = $val776;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_vals !== null) {
      if (!is_array($this->part_vals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_vals', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->part_vals));
        {
          foreach ($this->part_vals as $kiter777 => $viter778)
          {
            $xfer += $output->writeString($kiter777);
            $xfer += $output->writeString($viter778);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventType !== null) {
      $xfer += $output->writeFieldBegin('eventType', TType::I32, 4);
      $xfer += $output->writeI32($this->eventType);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_isPartitionMarkedForEvent_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;
  public $o5 = null;
  public $o6 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownDBException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownTableException',
          ),
        5 => array(
          'var' => 'o5',
          'type' => TType::STRUCT,
          'class' => '\metastore\UnknownPartitionException',
          ),
        6 => array(
          'var' => 'o6',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidPartitionException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
      if (isset($vals['o5'])) {
        $this->o5 = $vals['o5'];
      }
      if (isset($vals['o6'])) {
        $this->o6 = $vals['o6'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_isPartitionMarkedForEvent_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\UnknownDBException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\UnknownTableException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->o5 = new \metastore\UnknownPartitionException();
            $xfer += $this->o5->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->o6 = new \metastore\InvalidPartitionException();
            $xfer += $this->o6->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_isPartitionMarkedForEvent_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o5 !== null) {
      $xfer += $output->writeFieldBegin('o5', TType::STRUCT, 5);
      $xfer += $this->o5->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o6 !== null) {
      $xfer += $output->writeFieldBegin('o6', TType::STRUCT, 6);
      $xfer += $this->o6->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_index_args {
  static $_TSPEC;

  public $new_index = null;
  public $index_table = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'new_index',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        2 => array(
          'var' => 'index_table',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['new_index'])) {
        $this->new_index = $vals['new_index'];
      }
      if (isset($vals['index_table'])) {
        $this->index_table = $vals['index_table'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->new_index = new \metastore\Index();
            $xfer += $this->new_index->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->index_table = new \metastore\Table();
            $xfer += $this->index_table->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_args');
    if ($this->new_index !== null) {
      if (!is_object($this->new_index)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_index', TType::STRUCT, 1);
      $xfer += $this->new_index->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_table !== null) {
      if (!is_object($this->index_table)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('index_table', TType::STRUCT, 2);
      $xfer += $this->index_table->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_index_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Index();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\AlreadyExistsException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_index_args {
  static $_TSPEC;

  public $dbname = null;
  public $base_tbl_name = null;
  public $idx_name = null;
  public $new_idx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbname',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'base_tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'idx_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'new_idx',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbname'])) {
        $this->dbname = $vals['dbname'];
      }
      if (isset($vals['base_tbl_name'])) {
        $this->base_tbl_name = $vals['base_tbl_name'];
      }
      if (isset($vals['idx_name'])) {
        $this->idx_name = $vals['idx_name'];
      }
      if (isset($vals['new_idx'])) {
        $this->new_idx = $vals['new_idx'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_index_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->base_tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->idx_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->new_idx = new \metastore\Index();
            $xfer += $this->new_idx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_args');
    if ($this->dbname !== null) {
      $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
      $xfer += $output->writeString($this->dbname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->base_tbl_name !== null) {
      $xfer += $output->writeFieldBegin('base_tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->base_tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->idx_name !== null) {
      $xfer += $output->writeFieldBegin('idx_name', TType::STRING, 3);
      $xfer += $output->writeString($this->idx_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->new_idx !== null) {
      if (!is_object($this->new_idx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('new_idx', TType::STRUCT, 4);
      $xfer += $this->new_idx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_index_result {
  static $_TSPEC;

  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_index_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_index_by_name_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $index_name = null;
  public $deleteData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'index_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'deleteData',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['index_name'])) {
        $this->index_name = $vals['index_name'];
      }
      if (isset($vals['deleteData'])) {
        $this->deleteData = $vals['deleteData'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_index_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->index_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->deleteData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_name !== null) {
      $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
      $xfer += $output->writeString($this->index_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteData !== null) {
      $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
      $xfer += $output->writeBool($this->deleteData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_index_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_index_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_by_name_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $index_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'index_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['index_name'])) {
        $this->index_name = $vals['index_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->index_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->index_name !== null) {
      $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
      $xfer += $output->writeString($this->index_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Index',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Index();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_indexes_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_indexes = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_indexes',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_indexes'])) {
        $this->max_indexes = $vals['max_indexes'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_indexes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_indexes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_indexes !== null) {
      $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
      $xfer += $output->writeI16($this->max_indexes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_indexes_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Index',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_indexes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size779 = 0;
            $_etype782 = 0;
            $xfer += $input->readListBegin($_etype782, $_size779);
            for ($_i783 = 0; $_i783 < $_size779; ++$_i783)
            {
              $elem784 = null;
              $elem784 = new \metastore\Index();
              $xfer += $elem784->read($input);
              $this->success []= $elem784;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter785)
          {
            $xfer += $iter785->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_names_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $max_indexes = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'max_indexes',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['max_indexes'])) {
        $this->max_indexes = $vals['max_indexes'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->max_indexes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->max_indexes !== null) {
      $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
      $xfer += $output->writeI16($this->max_indexes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_index_names_result {
  static $_TSPEC;

  public $success = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_index_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size786 = 0;
            $_etype789 = 0;
            $xfer += $input->readListBegin($_etype789, $_size786);
            for ($_i790 = 0; $_i790 < $_size786; ++$_i790)
            {
              $elem791 = null;
              $xfer += $input->readString($elem791);
              $this->success []= $elem791;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter792)
          {
            $xfer += $output->writeString($iter792);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_table_column_statistics_args {
  static $_TSPEC;

  public $stats_obj = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stats_obj',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stats_obj'])) {
        $this->stats_obj = $vals['stats_obj'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->stats_obj = new \metastore\ColumnStatistics();
            $xfer += $this->stats_obj->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_table_column_statistics_args');
    if ($this->stats_obj !== null) {
      if (!is_object($this->stats_obj)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats_obj', TType::STRUCT, 1);
      $xfer += $this->stats_obj->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_table_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_table_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_partition_column_statistics_args {
  static $_TSPEC;

  public $stats_obj = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stats_obj',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stats_obj'])) {
        $this->stats_obj = $vals['stats_obj'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->stats_obj = new \metastore\ColumnStatistics();
            $xfer += $this->stats_obj->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_partition_column_statistics_args');
    if ($this->stats_obj !== null) {
      if (!is_object($this->stats_obj)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats_obj', TType::STRUCT, 1);
      $xfer += $this->stats_obj->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_update_partition_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_update_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_update_partition_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_column_statistics_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 3);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_table_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ColumnStatistics();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidInputException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_column_statistics_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_column_statistics_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_name = null;
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 4);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_partition_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\ColumnStatistics',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\ColumnStatistics();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidInputException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidObjectException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_column_statistics_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_partition_column_statistics_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $part_name = null;
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'part_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['part_name'])) {
        $this->part_name = $vals['part_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_partition_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->part_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_partition_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_name !== null) {
      $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
      $xfer += $output->writeString($this->part_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 4);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_partition_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_partition_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_partition_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_table_column_statistics_args {
  static $_TSPEC;

  public $db_name = null;
  public $tbl_name = null;
  public $col_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tbl_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'col_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['tbl_name'])) {
        $this->tbl_name = $vals['tbl_name'];
      }
      if (isset($vals['col_name'])) {
        $this->col_name = $vals['col_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_table_column_statistics_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tbl_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->col_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_table_column_statistics_args');
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl_name !== null) {
      $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
      $xfer += $output->writeString($this->tbl_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->col_name !== null) {
      $xfer += $output->writeFieldBegin('col_name', TType::STRING, 3);
      $xfer += $output->writeString($this->col_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_delete_table_column_statistics_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;
  public $o4 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        4 => array(
          'var' => 'o4',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidInputException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
      if (isset($vals['o4'])) {
        $this->o4 = $vals['o4'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_delete_table_column_statistics_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\InvalidObjectException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->o4 = new \metastore\InvalidInputException();
            $xfer += $this->o4->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_delete_table_column_statistics_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o4 !== null) {
      $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
      $xfer += $this->o4->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_user_args {
  static $_TSPEC;

  public $user = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user',
          'type' => TType::STRUCT,
          'class' => '\metastore\User',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_user_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->user = new \metastore\User();
            $xfer += $this->user->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_user_args');
    if ($this->user !== null) {
      if (!is_object($this->user)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('user', TType::STRUCT, 1);
      $xfer += $this->user->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_user_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_user_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_user_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_user_args {
  static $_TSPEC;

  public $user_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_user_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_user_args');
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 1);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_user_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_user_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_user_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modify_user_args {
  static $_TSPEC;

  public $user = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user',
          'type' => TType::STRUCT,
          'class' => '\metastore\User',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modify_user_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->user = new \metastore\User();
            $xfer += $this->user->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modify_user_args');
    if ($this->user !== null) {
      if (!is_object($this->user)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('user', TType::STRUCT, 1);
      $xfer += $this->user->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modify_user_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modify_user_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modify_user_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_users_names_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_users_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_users_names_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_users_names_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_users_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size793 = 0;
            $_etype796 = 0;
            $xfer += $input->readListBegin($_etype796, $_size793);
            for ($_i797 = 0; $_i797 < $_size793; ++$_i797)
            {
              $elem798 = null;
              $xfer += $input->readString($elem798);
              $this->success []= $elem798;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_users_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter799)
          {
            $xfer += $output->writeString($iter799);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_users_args {
  static $_TSPEC;

  public $db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db',
          'type' => TType::STRUCT,
          'class' => '\metastore\Database',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_users_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->db = new \metastore\Database();
            $xfer += $this->db->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_users_args');
    if ($this->db !== null) {
      if (!is_object($this->db)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('db', TType::STRUCT, 1);
      $xfer += $this->db->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_users_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_users_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size800 = 0;
            $_etype803 = 0;
            $xfer += $input->readListBegin($_etype803, $_size800);
            for ($_i804 = 0; $_i804 < $_size800; ++$_i804)
            {
              $elem805 = null;
              $xfer += $input->readString($elem805);
              $this->success []= $elem805;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_users_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter806)
          {
            $xfer += $output->writeString($iter806);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_authentication_args {
  static $_TSPEC;

  public $user_name = null;
  public $passwd = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'passwd',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['passwd'])) {
        $this->passwd = $vals['passwd'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_authentication_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->passwd);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_authentication_args');
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 1);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->passwd !== null) {
      $xfer += $output->writeFieldBegin('passwd', TType::STRING, 2);
      $xfer += $output->writeString($this->passwd);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_authentication_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_authentication_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_authentication_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_user_authority_check_args {
  static $_TSPEC;

  public $user = null;
  public $tbl = null;
  public $ops = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user',
          'type' => TType::STRUCT,
          'class' => '\metastore\User',
          ),
        2 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        3 => array(
          'var' => 'ops',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user'])) {
        $this->user = $vals['user'];
      }
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['ops'])) {
        $this->ops = $vals['ops'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_user_authority_check_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->user = new \metastore\User();
            $xfer += $this->user->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->ops = array();
            $_size807 = 0;
            $_etype810 = 0;
            $xfer += $input->readListBegin($_etype810, $_size807);
            for ($_i811 = 0; $_i811 < $_size807; ++$_i811)
            {
              $elem812 = null;
              $xfer += $input->readI32($elem812);
              $this->ops []= $elem812;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_user_authority_check_args');
    if ($this->user !== null) {
      if (!is_object($this->user)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('user', TType::STRUCT, 1);
      $xfer += $this->user->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 2);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ops !== null) {
      if (!is_array($this->ops)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ops', TType::LST, 3);
      {
        $output->writeListBegin(TType::I32, count($this->ops));
        {
          foreach ($this->ops as $iter813)
          {
            $xfer += $output->writeI32($iter813);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_user_authority_check_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_user_authority_check_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_user_authority_check_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_role_args {
  static $_TSPEC;

  public $role = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role',
          'type' => TType::STRUCT,
          'class' => '\metastore\Role',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role'])) {
        $this->role = $vals['role'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->role = new \metastore\Role();
            $xfer += $this->role->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_args');
    if ($this->role !== null) {
      if (!is_object($this->role)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('role', TType::STRUCT, 1);
      $xfer += $this->role->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_role_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_role_args {
  static $_TSPEC;

  public $role_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_drop_role_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_drop_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_names_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_names_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_role_names_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_role_names_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size814 = 0;
            $_etype817 = 0;
            $xfer += $input->readListBegin($_etype817, $_size814);
            for ($_i818 = 0; $_i818 < $_size814; ++$_i818)
            {
              $elem819 = null;
              $xfer += $input->readString($elem819);
              $this->success []= $elem819;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter820)
          {
            $xfer += $output->writeString($iter820);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_role_args {
  static $_TSPEC;

  public $role_name = null;
  public $principal_name = null;
  public $principal_type = null;
  public $grantor = null;
  public $grantorType = null;
  public $grant_option = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'grantor',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'grantorType',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'grant_option',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
      if (isset($vals['grantor'])) {
        $this->grantor = $vals['grantor'];
      }
      if (isset($vals['grantorType'])) {
        $this->grantorType = $vals['grantorType'];
      }
      if (isset($vals['grant_option'])) {
        $this->grant_option = $vals['grant_option'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grantor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->grantorType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->grant_option);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantor !== null) {
      $xfer += $output->writeFieldBegin('grantor', TType::STRING, 4);
      $xfer += $output->writeString($this->grantor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grantorType !== null) {
      $xfer += $output->writeFieldBegin('grantorType', TType::I32, 5);
      $xfer += $output->writeI32($this->grantorType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grant_option !== null) {
      $xfer += $output->writeFieldBegin('grant_option', TType::BOOL, 6);
      $xfer += $output->writeBool($this->grant_option);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_role_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_role_args {
  static $_TSPEC;

  public $role_name = null;
  public $principal_name = null;
  public $principal_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'role_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['role_name'])) {
        $this->role_name = $vals['role_name'];
      }
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_role_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_args');
    if ($this->role_name !== null) {
      $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
      $xfer += $output->writeString($this->role_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_role_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_role_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_roles_args {
  static $_TSPEC;

  public $principal_name = null;
  public $principal_type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_roles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_args');
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_roles_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Role',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_roles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size821 = 0;
            $_etype824 = 0;
            $xfer += $input->readListBegin($_etype824, $_size821);
            for ($_i825 = 0; $_i825 < $_size821; ++$_i825)
            {
              $elem826 = null;
              $elem826 = new \metastore\Role();
              $xfer += $elem826->read($input);
              $this->success []= $elem826;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter827)
          {
            $xfer += $iter827->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_privilege_set_args {
  static $_TSPEC;

  public $hiveObject = null;
  public $user_name = null;
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hiveObject',
          'type' => TType::STRUCT,
          'class' => '\metastore\HiveObjectRef',
          ),
        2 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hiveObject'])) {
        $this->hiveObject = $vals['hiveObject'];
      }
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_privilege_set_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->hiveObject = new \metastore\HiveObjectRef();
            $xfer += $this->hiveObject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size828 = 0;
            $_etype831 = 0;
            $xfer += $input->readListBegin($_etype831, $_size828);
            for ($_i832 = 0; $_i832 < $_size828; ++$_i832)
            {
              $elem833 = null;
              $xfer += $input->readString($elem833);
              $this->group_names []= $elem833;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_args');
    if ($this->hiveObject !== null) {
      if (!is_object($this->hiveObject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
      $xfer += $this->hiveObject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 2);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter834)
          {
            $xfer += $output->writeString($iter834);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_privilege_set_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrincipalPrivilegeSet',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_privilege_set_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\PrincipalPrivilegeSet();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_privileges_args {
  static $_TSPEC;

  public $principal_name = null;
  public $principal_type = null;
  public $hiveObject = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'principal_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'principal_type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'hiveObject',
          'type' => TType::STRUCT,
          'class' => '\metastore\HiveObjectRef',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['principal_name'])) {
        $this->principal_name = $vals['principal_name'];
      }
      if (isset($vals['principal_type'])) {
        $this->principal_type = $vals['principal_type'];
      }
      if (isset($vals['hiveObject'])) {
        $this->hiveObject = $vals['hiveObject'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->principal_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->hiveObject = new \metastore\HiveObjectRef();
            $xfer += $this->hiveObject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_args');
    if ($this->principal_name !== null) {
      $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
      $xfer += $output->writeString($this->principal_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->principal_type !== null) {
      $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
      $xfer += $output->writeI32($this->principal_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hiveObject !== null) {
      if (!is_object($this->hiveObject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 3);
      $xfer += $this->hiveObject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_list_privileges_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\HiveObjectPrivilege',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_list_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size835 = 0;
            $_etype838 = 0;
            $xfer += $input->readListBegin($_etype838, $_size835);
            for ($_i839 = 0; $_i839 < $_size835; ++$_i839)
            {
              $elem840 = null;
              $elem840 = new \metastore\HiveObjectPrivilege();
              $xfer += $elem840->read($input);
              $this->success []= $elem840;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter841)
          {
            $xfer += $iter841->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_privileges_args {
  static $_TSPEC;

  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeBag',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrivilegeBag();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_args');
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_grant_privileges_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_grant_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_privileges_args {
  static $_TSPEC;

  public $privileges = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'privileges',
          'type' => TType::STRUCT,
          'class' => '\metastore\PrivilegeBag',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['privileges'])) {
        $this->privileges = $vals['privileges'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_privileges_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->privileges = new \metastore\PrivilegeBag();
            $xfer += $this->privileges->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_args');
    if ($this->privileges !== null) {
      if (!is_object($this->privileges)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
      $xfer += $this->privileges->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_revoke_privileges_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_revoke_privileges_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_ugi_args {
  static $_TSPEC;

  public $user_name = null;
  public $group_names = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'user_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'group_names',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['user_name'])) {
        $this->user_name = $vals['user_name'];
      }
      if (isset($vals['group_names'])) {
        $this->group_names = $vals['group_names'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_ugi_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->user_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->group_names = array();
            $_size842 = 0;
            $_etype845 = 0;
            $xfer += $input->readListBegin($_etype845, $_size842);
            for ($_i846 = 0; $_i846 < $_size842; ++$_i846)
            {
              $elem847 = null;
              $xfer += $input->readString($elem847);
              $this->group_names []= $elem847;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_args');
    if ($this->user_name !== null) {
      $xfer += $output->writeFieldBegin('user_name', TType::STRING, 1);
      $xfer += $output->writeString($this->user_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group_names !== null) {
      if (!is_array($this->group_names)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('group_names', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->group_names));
        {
          foreach ($this->group_names as $iter848)
          {
            $xfer += $output->writeString($iter848);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_set_ugi_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_set_ugi_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size849 = 0;
            $_etype852 = 0;
            $xfer += $input->readListBegin($_etype852, $_size849);
            for ($_i853 = 0; $_i853 < $_size849; ++$_i853)
            {
              $elem854 = null;
              $xfer += $input->readString($elem854);
              $this->success []= $elem854;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_set_ugi_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter855)
          {
            $xfer += $output->writeString($iter855);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_delegation_token_args {
  static $_TSPEC;

  public $token_owner = null;
  public $renewer_kerberos_principal_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_owner',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'renewer_kerberos_principal_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_owner'])) {
        $this->token_owner = $vals['token_owner'];
      }
      if (isset($vals['renewer_kerberos_principal_name'])) {
        $this->renewer_kerberos_principal_name = $vals['renewer_kerberos_principal_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->renewer_kerberos_principal_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_args');
    if ($this->token_owner !== null) {
      $xfer += $output->writeFieldBegin('token_owner', TType::STRING, 1);
      $xfer += $output->writeString($this->token_owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->renewer_kerberos_principal_name !== null) {
      $xfer += $output->writeFieldBegin('renewer_kerberos_principal_name', TType::STRING, 2);
      $xfer += $output->writeString($this->renewer_kerberos_principal_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_delegation_token_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_renew_delegation_token_args {
  static $_TSPEC;

  public $token_str_form = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_str_form',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_str_form'])) {
        $this->token_str_form = $vals['token_str_form'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_renew_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_str_form);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_args');
    if ($this->token_str_form !== null) {
      $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
      $xfer += $output->writeString($this->token_str_form);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_renew_delegation_token_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_renew_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cancel_delegation_token_args {
  static $_TSPEC;

  public $token_str_form = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token_str_form',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token_str_form'])) {
        $this->token_str_form = $vals['token_str_form'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cancel_delegation_token_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token_str_form);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_args');
    if ($this->token_str_form !== null) {
      $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
      $xfer += $output->writeString($this->token_str_form);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_cancel_delegation_token_result {
  static $_TSPEC;

  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_cancel_delegation_token_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_file_args {
  static $_TSPEC;

  public $node_name = null;
  public $repnr = null;
  public $db_name = null;
  public $table_name = null;
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'repnr',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SplitValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
      if (isset($vals['repnr'])) {
        $this->repnr = $vals['repnr'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_file_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->repnr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size856 = 0;
            $_etype859 = 0;
            $xfer += $input->readListBegin($_etype859, $_size856);
            for ($_i860 = 0; $_i860 < $_size856; ++$_i860)
            {
              $elem861 = null;
              $elem861 = new \metastore\SplitValue();
              $xfer += $elem861->read($input);
              $this->values []= $elem861;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_file_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->repnr !== null) {
      $xfer += $output->writeFieldBegin('repnr', TType::I32, 2);
      $xfer += $output->writeI32($this->repnr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 3);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 4);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter862)
          {
            $xfer += $iter862->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_file_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_file_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\SFile();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_file_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_file_by_policy_args {
  static $_TSPEC;

  public $policy = null;
  public $repnr = null;
  public $db_name = null;
  public $table_name = null;
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'policy',
          'type' => TType::STRUCT,
          'class' => '\metastore\CreatePolicy',
          ),
        2 => array(
          'var' => 'repnr',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'db_name',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'table_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SplitValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['policy'])) {
        $this->policy = $vals['policy'];
      }
      if (isset($vals['repnr'])) {
        $this->repnr = $vals['repnr'];
      }
      if (isset($vals['db_name'])) {
        $this->db_name = $vals['db_name'];
      }
      if (isset($vals['table_name'])) {
        $this->table_name = $vals['table_name'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_file_by_policy_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->policy = new \metastore\CreatePolicy();
            $xfer += $this->policy->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->repnr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->table_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size863 = 0;
            $_etype866 = 0;
            $xfer += $input->readListBegin($_etype866, $_size863);
            for ($_i867 = 0; $_i867 < $_size863; ++$_i867)
            {
              $elem868 = null;
              $elem868 = new \metastore\SplitValue();
              $xfer += $elem868->read($input);
              $this->values []= $elem868;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_file_by_policy_args');
    if ($this->policy !== null) {
      if (!is_object($this->policy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('policy', TType::STRUCT, 1);
      $xfer += $this->policy->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->repnr !== null) {
      $xfer += $output->writeFieldBegin('repnr', TType::I32, 2);
      $xfer += $output->writeI32($this->repnr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->db_name !== null) {
      $xfer += $output->writeFieldBegin('db_name', TType::STRING, 3);
      $xfer += $output->writeString($this->db_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->table_name !== null) {
      $xfer += $output->writeFieldBegin('table_name', TType::STRING, 4);
      $xfer += $output->writeString($this->table_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter869)
          {
            $xfer += $iter869->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_file_by_policy_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_file_by_policy_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\SFile();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_file_by_policy_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_close_file_args {
  static $_TSPEC;

  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'file',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_close_file_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->file = new \metastore\SFile();
            $xfer += $this->file->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_close_file_args');
    if ($this->file !== null) {
      if (!is_object($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::STRUCT, 1);
      $xfer += $this->file->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_close_file_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_close_file_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_close_file_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_online_filelocation_args {
  static $_TSPEC;

  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'file',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_online_filelocation_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->file = new \metastore\SFile();
            $xfer += $this->file->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_online_filelocation_args');
    if ($this->file !== null) {
      if (!is_object($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::STRUCT, 1);
      $xfer += $this->file->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_online_filelocation_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_online_filelocation_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_online_filelocation_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_toggle_safemode_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_toggle_safemode_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_toggle_safemode_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_toggle_safemode_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_toggle_safemode_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_toggle_safemode_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_by_id_args {
  static $_TSPEC;

  public $fid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fid',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fid'])) {
        $this->fid = $vals['fid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_by_id_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->fid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_by_id_args');
    if ($this->fid !== null) {
      $xfer += $output->writeFieldBegin('fid', TType::I64, 1);
      $xfer += $output->writeI64($this->fid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_by_id_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_by_id_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\SFile();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_by_id_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_by_name_args {
  static $_TSPEC;

  public $node = null;
  public $devid = null;
  public $location = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'devid',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'location',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node'])) {
        $this->node = $vals['node'];
      }
      if (isset($vals['devid'])) {
        $this->devid = $vals['devid'];
      }
      if (isset($vals['location'])) {
        $this->location = $vals['location'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_by_name_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->location);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_by_name_args');
    if ($this->node !== null) {
      $xfer += $output->writeFieldBegin('node', TType::STRING, 1);
      $xfer += $output->writeString($this->node);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->devid !== null) {
      $xfer += $output->writeFieldBegin('devid', TType::STRING, 2);
      $xfer += $output->writeString($this->devid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->location !== null) {
      $xfer += $output->writeFieldBegin('location', TType::STRING, 3);
      $xfer += $output->writeString($this->location);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_file_by_name_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_file_by_name_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\SFile();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_file_by_name_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rm_file_logical_args {
  static $_TSPEC;

  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'file',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rm_file_logical_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->file = new \metastore\SFile();
            $xfer += $this->file->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rm_file_logical_args');
    if ($this->file !== null) {
      if (!is_object($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::STRUCT, 1);
      $xfer += $this->file->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rm_file_logical_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rm_file_logical_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rm_file_logical_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_restore_file_args {
  static $_TSPEC;

  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'file',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_restore_file_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->file = new \metastore\SFile();
            $xfer += $this->file->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_restore_file_args');
    if ($this->file !== null) {
      if (!is_object($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::STRUCT, 1);
      $xfer += $this->file->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_restore_file_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_restore_file_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_restore_file_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rm_file_physical_args {
  static $_TSPEC;

  public $file = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'file',
          'type' => TType::STRUCT,
          'class' => '\metastore\SFile',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['file'])) {
        $this->file = $vals['file'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rm_file_physical_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->file = new \metastore\SFile();
            $xfer += $this->file->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rm_file_physical_args');
    if ($this->file !== null) {
      if (!is_object($this->file)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('file', TType::STRUCT, 1);
      $xfer += $this->file->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_rm_file_physical_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\FileOperationException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_rm_file_physical_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\FileOperationException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_rm_file_physical_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_node_args {
  static $_TSPEC;

  public $node_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_node_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_node_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_node_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Node',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_node_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Node();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_node_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_node_args {
  static $_TSPEC;

  public $node_name = null;
  public $ipl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'ipl',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
      if (isset($vals['ipl'])) {
        $this->ipl = $vals['ipl'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_node_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->ipl = array();
            $_size870 = 0;
            $_etype873 = 0;
            $xfer += $input->readListBegin($_etype873, $_size870);
            for ($_i874 = 0; $_i874 < $_size870; ++$_i874)
            {
              $elem875 = null;
              $xfer += $input->readString($elem875);
              $this->ipl []= $elem875;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_node_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ipl !== null) {
      if (!is_array($this->ipl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ipl', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->ipl));
        {
          foreach ($this->ipl as $iter876)
          {
            $xfer += $output->writeString($iter876);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_add_node_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Node',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_add_node_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Node();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_node_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_del_node_args {
  static $_TSPEC;

  public $node_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_del_node_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_del_node_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_del_node_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_del_node_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_del_node_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_device_args {
  static $_TSPEC;

  public $devid = null;
  public $prop = null;
  public $node_name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'devid',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'prop',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['devid'])) {
        $this->devid = $vals['devid'];
      }
      if (isset($vals['prop'])) {
        $this->prop = $vals['prop'];
      }
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_device_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->prop);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_device_args');
    if ($this->devid !== null) {
      $xfer += $output->writeFieldBegin('devid', TType::STRING, 1);
      $xfer += $output->writeString($this->devid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prop !== null) {
      $xfer += $output->writeFieldBegin('prop', TType::I32, 2);
      $xfer += $output->writeI32($this->prop);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 3);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_create_device_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Device',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_create_device_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Device();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_device_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_device_args {
  static $_TSPEC;

  public $devid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'devid',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['devid'])) {
        $this->devid = $vals['devid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_device_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_device_args');
    if ($this->devid !== null) {
      $xfer += $output->writeFieldBegin('devid', TType::STRING, 1);
      $xfer += $output->writeString($this->devid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_device_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Device',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_device_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Device();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_device_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_del_device_args {
  static $_TSPEC;

  public $devid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'devid',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['devid'])) {
        $this->devid = $vals['devid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_del_device_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_del_device_args');
    if ($this->devid !== null) {
      $xfer += $output->writeFieldBegin('devid', TType::STRING, 1);
      $xfer += $output->writeString($this->devid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_del_device_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_del_device_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_del_device_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modify_device_args {
  static $_TSPEC;

  public $dev = null;
  public $node = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dev',
          'type' => TType::STRUCT,
          'class' => '\metastore\Device',
          ),
        2 => array(
          'var' => 'node',
          'type' => TType::STRUCT,
          'class' => '\metastore\Node',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dev'])) {
        $this->dev = $vals['dev'];
      }
      if (isset($vals['node'])) {
        $this->node = $vals['node'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modify_device_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->dev = new \metastore\Device();
            $xfer += $this->dev->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->node = new \metastore\Node();
            $xfer += $this->node->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modify_device_args');
    if ($this->dev !== null) {
      if (!is_object($this->dev)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dev', TType::STRUCT, 1);
      $xfer += $this->dev->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->node !== null) {
      if (!is_object($this->node)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('node', TType::STRUCT, 2);
      $xfer += $this->node->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modify_device_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Device',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modify_device_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Device();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modify_device_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_node_args {
  static $_TSPEC;

  public $node_name = null;
  public $ipl = null;
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'ipl',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
      if (isset($vals['ipl'])) {
        $this->ipl = $vals['ipl'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_node_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->ipl = array();
            $_size877 = 0;
            $_etype880 = 0;
            $xfer += $input->readListBegin($_etype880, $_size877);
            for ($_i881 = 0; $_i881 < $_size877; ++$_i881)
            {
              $elem882 = null;
              $xfer += $input->readString($elem882);
              $this->ipl []= $elem882;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_node_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ipl !== null) {
      if (!is_array($this->ipl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ipl', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->ipl));
        {
          foreach ($this->ipl as $iter883)
          {
            $xfer += $output->writeString($iter883);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 3);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_alter_node_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\Node',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_alter_node_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\Node();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_node_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_find_best_nodes_args {
  static $_TSPEC;

  public $nr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nr',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nr'])) {
        $this->nr = $vals['nr'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_find_best_nodes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_find_best_nodes_args');
    if ($this->nr !== null) {
      $xfer += $output->writeFieldBegin('nr', TType::I32, 1);
      $xfer += $output->writeI32($this->nr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_find_best_nodes_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Node',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_find_best_nodes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size884 = 0;
            $_etype887 = 0;
            $xfer += $input->readListBegin($_etype887, $_size884);
            for ($_i888 = 0; $_i888 < $_size884; ++$_i888)
            {
              $elem889 = null;
              $elem889 = new \metastore\Node();
              $xfer += $elem889->read($input);
              $this->success []= $elem889;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_find_best_nodes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter890)
          {
            $xfer += $iter890->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_find_best_nodes_in_groups_args {
  static $_TSPEC;

  public $dbName = null;
  public $tableName = null;
  public $nr = null;
  public $policy = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'nr',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'policy',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['nr'])) {
        $this->nr = $vals['nr'];
      }
      if (isset($vals['policy'])) {
        $this->policy = $vals['policy'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_find_best_nodes_in_groups_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->policy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_find_best_nodes_in_groups_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nr !== null) {
      $xfer += $output->writeFieldBegin('nr', TType::I32, 3);
      $xfer += $output->writeI32($this->nr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->policy !== null) {
      $xfer += $output->writeFieldBegin('policy', TType::I32, 4);
      $xfer += $output->writeI32($this->policy);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_find_best_nodes_in_groups_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Node',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_find_best_nodes_in_groups_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size891 = 0;
            $_etype894 = 0;
            $xfer += $input->readListBegin($_etype894, $_size891);
            for ($_i895 = 0; $_i895 < $_size891; ++$_i895)
            {
              $elem896 = null;
              $elem896 = new \metastore\Node();
              $xfer += $elem896->read($input);
              $this->success []= $elem896;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_find_best_nodes_in_groups_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter897)
          {
            $xfer += $iter897->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_nodes_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_nodes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_nodes_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_get_all_nodes_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Node',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_get_all_nodes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size898 = 0;
            $_etype901 = 0;
            $xfer += $input->readListBegin($_etype901, $_size898);
            for ($_i902 = 0; $_i902 < $_size898; ++$_i902)
            {
              $elem903 = null;
              $elem903 = new \metastore\Node();
              $xfer += $elem903->read($input);
              $this->success []= $elem903;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_nodes_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter904)
          {
            $xfer += $iter904->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getDMStatus_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getDMStatus_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getDMStatus_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getDMStatus_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getDMStatus_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getDMStatus_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getNodeInfo_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getNodeInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getNodeInfo_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getNodeInfo_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getNodeInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getNodeInfo_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_in_args {
  static $_TSPEC;

  public $tbl = null;
  public $files = null;
  public $idxs = null;
  public $from_db = null;
  public $to_devid = null;
  public $fileMap = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'files',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        3 => array(
          'var' => 'idxs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Index',
            ),
          ),
        4 => array(
          'var' => 'from_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'to_devid',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'fileMap',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileLocation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
      if (isset($vals['idxs'])) {
        $this->idxs = $vals['idxs'];
      }
      if (isset($vals['from_db'])) {
        $this->from_db = $vals['from_db'];
      }
      if (isset($vals['to_devid'])) {
        $this->to_devid = $vals['to_devid'];
      }
      if (isset($vals['fileMap'])) {
        $this->fileMap = $vals['fileMap'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_in_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->files = array();
            $_size905 = 0;
            $_ktype906 = 0;
            $_vtype907 = 0;
            $xfer += $input->readMapBegin($_ktype906, $_vtype907, $_size905);
            for ($_i909 = 0; $_i909 < $_size905; ++$_i909)
            {
              $key910 = 0;
              $val911 = new \metastore\SFile();
              $xfer += $input->readI64($key910);
              $val911 = new \metastore\SFile();
              $xfer += $val911->read($input);
              $this->files[$key910] = $val911;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->idxs = array();
            $_size912 = 0;
            $_etype915 = 0;
            $xfer += $input->readListBegin($_etype915, $_size912);
            for ($_i916 = 0; $_i916 < $_size912; ++$_i916)
            {
              $elem917 = null;
              $elem917 = new \metastore\Index();
              $xfer += $elem917->read($input);
              $this->idxs []= $elem917;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->from_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->fileMap = array();
            $_size918 = 0;
            $_ktype919 = 0;
            $_vtype920 = 0;
            $xfer += $input->readMapBegin($_ktype919, $_vtype920, $_size918);
            for ($_i922 = 0; $_i922 < $_size918; ++$_i922)
            {
              $key923 = 0;
              $val924 = new \metastore\SFileLocation();
              $xfer += $input->readI64($key923);
              $val924 = new \metastore\SFileLocation();
              $xfer += $val924->read($input);
              $this->fileMap[$key923] = $val924;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_in_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::I64, TType::STRUCT, count($this->files));
        {
          foreach ($this->files as $kiter925 => $viter926)
          {
            $xfer += $output->writeI64($kiter925);
            $xfer += $viter926->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->idxs !== null) {
      if (!is_array($this->idxs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('idxs', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->idxs));
        {
          foreach ($this->idxs as $iter927)
          {
            $xfer += $iter927->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->from_db !== null) {
      $xfer += $output->writeFieldBegin('from_db', TType::STRING, 4);
      $xfer += $output->writeString($this->from_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_devid !== null) {
      $xfer += $output->writeFieldBegin('to_devid', TType::STRING, 5);
      $xfer += $output->writeString($this->to_devid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileMap !== null) {
      if (!is_array($this->fileMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileMap', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::I64, TType::STRUCT, count($this->fileMap));
        {
          foreach ($this->fileMap as $kiter928 => $viter929)
          {
            $xfer += $output->writeI64($kiter928);
            $xfer += $viter929->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_in_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_in_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_in_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_stage1_args {
  static $_TSPEC;

  public $dbName = null;
  public $tableName = null;
  public $files = null;
  public $to_db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        4 => array(
          'var' => 'to_db',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
      if (isset($vals['to_db'])) {
        $this->to_db = $vals['to_db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_stage1_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size930 = 0;
            $_etype933 = 0;
            $xfer += $input->readListBegin($_etype933, $_size930);
            for ($_i934 = 0; $_i934 < $_size930; ++$_i934)
            {
              $elem935 = null;
              $xfer += $input->readI64($elem935);
              $this->files []= $elem935;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_stage1_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 3);
      {
        $output->writeListBegin(TType::I64, count($this->files));
        {
          foreach ($this->files as $iter936)
          {
            $xfer += $output->writeI64($iter936);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_db !== null) {
      $xfer += $output->writeFieldBegin('to_db', TType::STRING, 4);
      $xfer += $output->writeString($this->to_db);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_stage1_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileLocation',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_stage1_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size937 = 0;
            $_etype940 = 0;
            $xfer += $input->readListBegin($_etype940, $_size937);
            for ($_i941 = 0; $_i941 < $_size937; ++$_i941)
            {
              $elem942 = null;
              $elem942 = new \metastore\SFileLocation();
              $xfer += $elem942->read($input);
              $this->success []= $elem942;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_stage1_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter943)
          {
            $xfer += $iter943->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_stage2_args {
  static $_TSPEC;

  public $dbName = null;
  public $tableName = null;
  public $files = null;
  public $from_db = null;
  public $to_db = null;
  public $to_devid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'files',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        4 => array(
          'var' => 'from_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'to_db',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'to_devid',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['files'])) {
        $this->files = $vals['files'];
      }
      if (isset($vals['from_db'])) {
        $this->from_db = $vals['from_db'];
      }
      if (isset($vals['to_db'])) {
        $this->to_db = $vals['to_db'];
      }
      if (isset($vals['to_devid'])) {
        $this->to_devid = $vals['to_devid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_stage2_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->files = array();
            $_size944 = 0;
            $_etype947 = 0;
            $xfer += $input->readListBegin($_etype947, $_size944);
            for ($_i948 = 0; $_i948 < $_size944; ++$_i948)
            {
              $elem949 = null;
              $xfer += $input->readI64($elem949);
              $this->files []= $elem949;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->from_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_stage2_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->files !== null) {
      if (!is_array($this->files)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('files', TType::LST, 3);
      {
        $output->writeListBegin(TType::I64, count($this->files));
        {
          foreach ($this->files as $iter950)
          {
            $xfer += $output->writeI64($iter950);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->from_db !== null) {
      $xfer += $output->writeFieldBegin('from_db', TType::STRING, 4);
      $xfer += $output->writeString($this->from_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_db !== null) {
      $xfer += $output->writeFieldBegin('to_db', TType::STRING, 5);
      $xfer += $output->writeString($this->to_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_devid !== null) {
      $xfer += $output->writeFieldBegin('to_devid', TType::STRING, 6);
      $xfer += $output->writeString($this->to_devid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate_stage2_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate_stage2_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate_stage2_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_in_args {
  static $_TSPEC;

  public $tbl = null;
  public $parts = null;
  public $idxs = null;
  public $from_db = null;
  public $to_nas_devid = null;
  public $fileMap = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tbl',
          'type' => TType::STRUCT,
          'class' => '\metastore\Table',
          ),
        2 => array(
          'var' => 'parts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Partition',
            ),
          ),
        3 => array(
          'var' => 'idxs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\Index',
            ),
          ),
        4 => array(
          'var' => 'from_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'to_nas_devid',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'fileMap',
          'type' => TType::MAP,
          'ktype' => TType::I64,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I64,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileLocation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tbl'])) {
        $this->tbl = $vals['tbl'];
      }
      if (isset($vals['parts'])) {
        $this->parts = $vals['parts'];
      }
      if (isset($vals['idxs'])) {
        $this->idxs = $vals['idxs'];
      }
      if (isset($vals['from_db'])) {
        $this->from_db = $vals['from_db'];
      }
      if (isset($vals['to_nas_devid'])) {
        $this->to_nas_devid = $vals['to_nas_devid'];
      }
      if (isset($vals['fileMap'])) {
        $this->fileMap = $vals['fileMap'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_in_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tbl = new \metastore\Table();
            $xfer += $this->tbl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->parts = array();
            $_size951 = 0;
            $_etype954 = 0;
            $xfer += $input->readListBegin($_etype954, $_size951);
            for ($_i955 = 0; $_i955 < $_size951; ++$_i955)
            {
              $elem956 = null;
              $elem956 = new \metastore\Partition();
              $xfer += $elem956->read($input);
              $this->parts []= $elem956;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->idxs = array();
            $_size957 = 0;
            $_etype960 = 0;
            $xfer += $input->readListBegin($_etype960, $_size957);
            for ($_i961 = 0; $_i961 < $_size957; ++$_i961)
            {
              $elem962 = null;
              $elem962 = new \metastore\Index();
              $xfer += $elem962->read($input);
              $this->idxs []= $elem962;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->from_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_nas_devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->fileMap = array();
            $_size963 = 0;
            $_ktype964 = 0;
            $_vtype965 = 0;
            $xfer += $input->readMapBegin($_ktype964, $_vtype965, $_size963);
            for ($_i967 = 0; $_i967 < $_size963; ++$_i967)
            {
              $key968 = 0;
              $val969 = new \metastore\SFileLocation();
              $xfer += $input->readI64($key968);
              $val969 = new \metastore\SFileLocation();
              $xfer += $val969->read($input);
              $this->fileMap[$key968] = $val969;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_in_args');
    if ($this->tbl !== null) {
      if (!is_object($this->tbl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
      $xfer += $this->tbl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parts !== null) {
      if (!is_array($this->parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parts', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->parts));
        {
          foreach ($this->parts as $iter970)
          {
            $xfer += $iter970->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->idxs !== null) {
      if (!is_array($this->idxs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('idxs', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->idxs));
        {
          foreach ($this->idxs as $iter971)
          {
            $xfer += $iter971->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->from_db !== null) {
      $xfer += $output->writeFieldBegin('from_db', TType::STRING, 4);
      $xfer += $output->writeString($this->from_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_nas_devid !== null) {
      $xfer += $output->writeFieldBegin('to_nas_devid', TType::STRING, 5);
      $xfer += $output->writeString($this->to_nas_devid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileMap !== null) {
      if (!is_array($this->fileMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileMap', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::I64, TType::STRUCT, count($this->fileMap));
        {
          foreach ($this->fileMap as $kiter972 => $viter973)
          {
            $xfer += $output->writeI64($kiter972);
            $xfer += $viter973->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_in_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_in_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_in_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_stage1_args {
  static $_TSPEC;

  public $dbName = null;
  public $tableName = null;
  public $partNames = null;
  public $to_db = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'to_db',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['partNames'])) {
        $this->partNames = $vals['partNames'];
      }
      if (isset($vals['to_db'])) {
        $this->to_db = $vals['to_db'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_stage1_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->partNames = array();
            $_size974 = 0;
            $_etype977 = 0;
            $xfer += $input->readListBegin($_etype977, $_size974);
            for ($_i978 = 0; $_i978 < $_size974; ++$_i978)
            {
              $elem979 = null;
              $xfer += $input->readString($elem979);
              $this->partNames []= $elem979;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_stage1_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partNames !== null) {
      if (!is_array($this->partNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partNames', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->partNames));
        {
          foreach ($this->partNames as $iter980)
          {
            $xfer += $output->writeString($iter980);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_db !== null) {
      $xfer += $output->writeFieldBegin('to_db', TType::STRING, 4);
      $xfer += $output->writeString($this->to_db);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_stage1_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFileLocation',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_stage1_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size981 = 0;
            $_etype984 = 0;
            $xfer += $input->readListBegin($_etype984, $_size981);
            for ($_i985 = 0; $_i985 < $_size981; ++$_i985)
            {
              $elem986 = null;
              $elem986 = new \metastore\SFileLocation();
              $xfer += $elem986->read($input);
              $this->success []= $elem986;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_stage1_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter987)
          {
            $xfer += $iter987->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_stage2_args {
  static $_TSPEC;

  public $dbName = null;
  public $tableName = null;
  public $partNames = null;
  public $from_db = null;
  public $to_db = null;
  public $to_nas_devid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'partNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'from_db',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'to_db',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'to_nas_devid',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['partNames'])) {
        $this->partNames = $vals['partNames'];
      }
      if (isset($vals['from_db'])) {
        $this->from_db = $vals['from_db'];
      }
      if (isset($vals['to_db'])) {
        $this->to_db = $vals['to_db'];
      }
      if (isset($vals['to_nas_devid'])) {
        $this->to_nas_devid = $vals['to_nas_devid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_stage2_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->partNames = array();
            $_size988 = 0;
            $_etype991 = 0;
            $xfer += $input->readListBegin($_etype991, $_size988);
            for ($_i992 = 0; $_i992 < $_size988; ++$_i992)
            {
              $elem993 = null;
              $xfer += $input->readString($elem993);
              $this->partNames []= $elem993;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->from_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->to_nas_devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_stage2_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->partNames !== null) {
      if (!is_array($this->partNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('partNames', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->partNames));
        {
          foreach ($this->partNames as $iter994)
          {
            $xfer += $output->writeString($iter994);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->from_db !== null) {
      $xfer += $output->writeFieldBegin('from_db', TType::STRING, 4);
      $xfer += $output->writeString($this->from_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_db !== null) {
      $xfer += $output->writeFieldBegin('to_db', TType::STRING, 5);
      $xfer += $output->writeString($this->to_db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to_nas_devid !== null) {
      $xfer += $output->writeFieldBegin('to_nas_devid', TType::STRING, 6);
      $xfer += $output->writeString($this->to_nas_devid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_migrate2_stage2_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_migrate2_stage2_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_migrate2_stage2_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getMP_args {
  static $_TSPEC;

  public $node_name = null;
  public $devid = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'devid',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node_name'])) {
        $this->node_name = $vals['node_name'];
      }
      if (isset($vals['devid'])) {
        $this->devid = $vals['devid'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getMP_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->devid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getMP_args');
    if ($this->node_name !== null) {
      $xfer += $output->writeFieldBegin('node_name', TType::STRING, 1);
      $xfer += $output->writeString($this->node_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->devid !== null) {
      $xfer += $output->writeFieldBegin('devid', TType::STRING, 2);
      $xfer += $output->writeString($this->devid);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getMP_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getMP_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getMP_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getSessionId_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getSessionId_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getSessionId_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getSessionId_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getSessionId_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getSessionId_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_createSchema_args {
  static $_TSPEC;

  public $schema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\metastore\GlobalSchema',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_createSchema_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \metastore\GlobalSchema();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_createSchema_args');
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 1);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_createSchema_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_createSchema_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\InvalidObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_createSchema_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifySchema_args {
  static $_TSPEC;

  public $schemaName = null;
  public $schema = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'schema',
          'type' => TType::STRUCT,
          'class' => '\metastore\GlobalSchema',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['schema'])) {
        $this->schema = $vals['schema'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifySchema_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->schema = new \metastore\GlobalSchema();
            $xfer += $this->schema->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifySchema_args');
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 1);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schema !== null) {
      if (!is_object($this->schema)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 2);
      $xfer += $this->schema->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifySchema_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifySchema_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifySchema_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteSchema_args {
  static $_TSPEC;

  public $schemaName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteSchema_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteSchema_args');
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 1);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteSchema_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteSchema_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteSchema_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listSchemas_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listSchemas_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listSchemas_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listSchemas_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\GlobalSchema',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listSchemas_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size995 = 0;
            $_etype998 = 0;
            $xfer += $input->readListBegin($_etype998, $_size995);
            for ($_i999 = 0; $_i999 < $_size995; ++$_i999)
            {
              $elem1000 = null;
              $elem1000 = new \metastore\GlobalSchema();
              $xfer += $elem1000->read($input);
              $this->success []= $elem1000;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listSchemas_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1001)
          {
            $xfer += $iter1001->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getSchemaByName_args {
  static $_TSPEC;

  public $schemaName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getSchemaByName_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getSchemaByName_args');
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 1);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getSchemaByName_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\metastore\GlobalSchema',
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getSchemaByName_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \metastore\GlobalSchema();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\NoSuchObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getSchemaByName_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getTableNodeGroups_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getTableNodeGroups_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getTableNodeGroups_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getTableNodeGroups_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getTableNodeGroups_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1002 = 0;
            $_etype1005 = 0;
            $xfer += $input->readListBegin($_etype1005, $_size1002);
            for ($_i1006 = 0; $_i1006 < $_size1002; ++$_i1006)
            {
              $elem1007 = null;
              $elem1007 = new \metastore\NodeGroup();
              $xfer += $elem1007->read($input);
              $this->success []= $elem1007;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getTableNodeGroups_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1008)
          {
            $xfer += $iter1008->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getTableNodeFiles_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;
  public $nodeName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'nodeName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
      if (isset($vals['nodeName'])) {
        $this->nodeName = $vals['nodeName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getTableNodeFiles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->nodeName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getTableNodeFiles_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nodeName !== null) {
      $xfer += $output->writeFieldBegin('nodeName', TType::STRING, 3);
      $xfer += $output->writeString($this->nodeName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_getTableNodeFiles_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_getTableNodeFiles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1009 = 0;
            $_etype1012 = 0;
            $xfer += $input->readListBegin($_etype1012, $_size1009);
            for ($_i1013 = 0; $_i1013 < $_size1009; ++$_i1013)
            {
              $elem1014 = null;
              $elem1014 = new \metastore\SFile();
              $xfer += $elem1014->read($input);
              $this->success []= $elem1014;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_getTableNodeFiles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1015)
          {
            $xfer += $iter1015->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listTableFiles_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;
  public $from = null;
  public $to = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'from',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'to',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
      if (isset($vals['from'])) {
        $this->from = $vals['from'];
      }
      if (isset($vals['to'])) {
        $this->to = $vals['to'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listTableFiles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->from);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->to);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listTableFiles_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->from !== null) {
      $xfer += $output->writeFieldBegin('from', TType::I32, 3);
      $xfer += $output->writeI32($this->from);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->to !== null) {
      $xfer += $output->writeFieldBegin('to', TType::I32, 4);
      $xfer += $output->writeI32($this->to);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listTableFiles_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listTableFiles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1016 = 0;
            $_etype1019 = 0;
            $xfer += $input->readListBegin($_etype1019, $_size1016);
            for ($_i1020 = 0; $_i1020 < $_size1016; ++$_i1020)
            {
              $elem1021 = null;
              $xfer += $input->readI64($elem1021);
              $this->success []= $elem1021;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listTableFiles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter1022)
          {
            $xfer += $output->writeI64($iter1022);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listFilesByDigest_args {
  static $_TSPEC;

  public $digest = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'digest',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['digest'])) {
        $this->digest = $vals['digest'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listFilesByDigest_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->digest);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listFilesByDigest_args');
    if ($this->digest !== null) {
      $xfer += $output->writeFieldBegin('digest', TType::STRING, 1);
      $xfer += $output->writeString($this->digest);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listFilesByDigest_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listFilesByDigest_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1023 = 0;
            $_etype1026 = 0;
            $xfer += $input->readListBegin($_etype1026, $_size1023);
            for ($_i1027 = 0; $_i1027 < $_size1023; ++$_i1027)
            {
              $elem1028 = null;
              $xfer += $input->readI64($elem1028);
              $this->success []= $elem1028;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listFilesByDigest_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter1029)
          {
            $xfer += $output->writeI64($iter1029);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_filterTableFiles_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SplitValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_filterTableFiles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size1030 = 0;
            $_etype1033 = 0;
            $xfer += $input->readListBegin($_etype1033, $_size1030);
            for ($_i1034 = 0; $_i1034 < $_size1030; ++$_i1034)
            {
              $elem1035 = null;
              $elem1035 = new \metastore\SplitValue();
              $xfer += $elem1035->read($input);
              $this->values []= $elem1035;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_filterTableFiles_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter1036)
          {
            $xfer += $iter1036->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_filterTableFiles_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\SFile',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_filterTableFiles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1037 = 0;
            $_etype1040 = 0;
            $xfer += $input->readListBegin($_etype1040, $_size1037);
            for ($_i1041 = 0; $_i1041 < $_size1037; ++$_i1041)
            {
              $elem1042 = null;
              $elem1042 = new \metastore\SFile();
              $xfer += $elem1042->read($input);
              $this->success []= $elem1042;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_filterTableFiles_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1043)
          {
            $xfer += $iter1043->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_truncTableFiles_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_truncTableFiles_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_truncTableFiles_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_truncTableFiles_result {
  static $_TSPEC;

  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_truncTableFiles_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_truncTableFiles_result');
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeGroup_args {
  static $_TSPEC;

  public $ng = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ng',
          'type' => TType::STRUCT,
          'class' => '\metastore\NodeGroup',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeGroup_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ng = new \metastore\NodeGroup();
            $xfer += $this->ng->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeGroup_args');
    if ($this->ng !== null) {
      if (!is_object($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::STRUCT, 1);
      $xfer += $this->ng->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addNodeGroup_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\AlreadyExistsException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addNodeGroup_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\AlreadyExistsException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\MetaException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addNodeGroup_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyNodeGroup_args {
  static $_TSPEC;

  public $schemaName = null;
  public $ng = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'ng',
          'type' => TType::STRUCT,
          'class' => '\metastore\NodeGroup',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyNodeGroup_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ng = new \metastore\NodeGroup();
            $xfer += $this->ng->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyNodeGroup_args');
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 1);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ng !== null) {
      if (!is_object($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::STRUCT, 2);
      $xfer += $this->ng->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_modifyNodeGroup_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_modifyNodeGroup_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_modifyNodeGroup_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeGroup_args {
  static $_TSPEC;

  public $ng = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ng',
          'type' => TType::STRUCT,
          'class' => '\metastore\NodeGroup',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeGroup_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->ng = new \metastore\NodeGroup();
            $xfer += $this->ng->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeGroup_args');
    if ($this->ng !== null) {
      if (!is_object($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::STRUCT, 1);
      $xfer += $this->ng->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteNodeGroup_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteNodeGroup_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteNodeGroup_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodeGroups_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodeGroups_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodeGroups_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodeGroups_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodeGroups_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1044 = 0;
            $_etype1047 = 0;
            $xfer += $input->readListBegin($_etype1047, $_size1044);
            for ($_i1048 = 0; $_i1048 < $_size1044; ++$_i1048)
            {
              $elem1049 = null;
              $elem1049 = new \metastore\NodeGroup();
              $xfer += $elem1049->read($input);
              $this->success []= $elem1049;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodeGroups_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1050)
          {
            $xfer += $iter1050->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listDBNodeGroups_args {
  static $_TSPEC;

  public $dbName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listDBNodeGroups_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listDBNodeGroups_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listDBNodeGroups_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listDBNodeGroups_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1051 = 0;
            $_etype1054 = 0;
            $xfer += $input->readListBegin($_etype1054, $_size1051);
            for ($_i1055 = 0; $_i1055 < $_size1051; ++$_i1055)
            {
              $elem1056 = null;
              $elem1056 = new \metastore\NodeGroup();
              $xfer += $elem1056->read($input);
              $this->success []= $elem1056;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listDBNodeGroups_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1057)
          {
            $xfer += $iter1057->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodeGroupByNames_args {
  static $_TSPEC;

  public $ngNames = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'ngNames',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ngNames'])) {
        $this->ngNames = $vals['ngNames'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodeGroupByNames_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->ngNames = array();
            $_size1058 = 0;
            $_etype1061 = 0;
            $xfer += $input->readListBegin($_etype1061, $_size1058);
            for ($_i1062 = 0; $_i1062 < $_size1058; ++$_i1062)
            {
              $elem1063 = null;
              $xfer += $input->readString($elem1063);
              $this->ngNames []= $elem1063;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodeGroupByNames_args');
    if ($this->ngNames !== null) {
      if (!is_array($this->ngNames)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ngNames', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->ngNames));
        {
          foreach ($this->ngNames as $iter1064)
          {
            $xfer += $output->writeString($iter1064);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listNodeGroupByNames_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listNodeGroupByNames_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1065 = 0;
            $_etype1068 = 0;
            $xfer += $input->readListBegin($_etype1068, $_size1065);
            for ($_i1069 = 0; $_i1069 < $_size1065; ++$_i1069)
            {
              $elem1070 = null;
              $elem1070 = new \metastore\NodeGroup();
              $xfer += $elem1070->read($input);
              $this->success []= $elem1070;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listNodeGroupByNames_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1071)
          {
            $xfer += $iter1071->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addTableNodeDist_args {
  static $_TSPEC;

  public $db = null;
  public $tab = null;
  public $ng = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tab',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'ng',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
      if (isset($vals['tab'])) {
        $this->tab = $vals['tab'];
      }
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addTableNodeDist_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tab);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->ng = array();
            $_size1072 = 0;
            $_etype1075 = 0;
            $xfer += $input->readListBegin($_etype1075, $_size1072);
            for ($_i1076 = 0; $_i1076 < $_size1072; ++$_i1076)
            {
              $elem1077 = null;
              $xfer += $input->readString($elem1077);
              $this->ng []= $elem1077;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addTableNodeDist_args');
    if ($this->db !== null) {
      $xfer += $output->writeFieldBegin('db', TType::STRING, 1);
      $xfer += $output->writeString($this->db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tab !== null) {
      $xfer += $output->writeFieldBegin('tab', TType::STRING, 2);
      $xfer += $output->writeString($this->tab);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ng !== null) {
      if (!is_array($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->ng));
        {
          foreach ($this->ng as $iter1078)
          {
            $xfer += $output->writeString($iter1078);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_addTableNodeDist_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_addTableNodeDist_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_addTableNodeDist_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteTableNodeDist_args {
  static $_TSPEC;

  public $db = null;
  public $tab = null;
  public $ng = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'db',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tab',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'ng',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['db'])) {
        $this->db = $vals['db'];
      }
      if (isset($vals['tab'])) {
        $this->tab = $vals['tab'];
      }
      if (isset($vals['ng'])) {
        $this->ng = $vals['ng'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteTableNodeDist_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->db);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tab);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->ng = array();
            $_size1079 = 0;
            $_etype1082 = 0;
            $xfer += $input->readListBegin($_etype1082, $_size1079);
            for ($_i1083 = 0; $_i1083 < $_size1079; ++$_i1083)
            {
              $elem1084 = null;
              $xfer += $input->readString($elem1084);
              $this->ng []= $elem1084;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteTableNodeDist_args');
    if ($this->db !== null) {
      $xfer += $output->writeFieldBegin('db', TType::STRING, 1);
      $xfer += $output->writeString($this->db);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tab !== null) {
      $xfer += $output->writeFieldBegin('tab', TType::STRING, 2);
      $xfer += $output->writeString($this->tab);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ng !== null) {
      if (!is_array($this->ng)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ng', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->ng));
        {
          foreach ($this->ng as $iter1085)
          {
            $xfer += $output->writeString($iter1085);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_deleteTableNodeDist_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_deleteTableNodeDist_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_deleteTableNodeDist_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listTableNodeDists_args {
  static $_TSPEC;

  public $dbName = null;
  public $tabName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tabName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['tabName'])) {
        $this->tabName = $vals['tabName'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listTableNodeDists_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tabName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listTableNodeDists_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tabName !== null) {
      $xfer += $output->writeFieldBegin('tabName', TType::STRING, 2);
      $xfer += $output->writeString($this->tabName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_listTableNodeDists_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_listTableNodeDists_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size1086 = 0;
            $_etype1089 = 0;
            $xfer += $input->readListBegin($_etype1089, $_size1086);
            for ($_i1090 = 0; $_i1090 < $_size1086; ++$_i1090)
            {
              $elem1091 = null;
              $elem1091 = new \metastore\NodeGroup();
              $xfer += $elem1091->read($input);
              $this->success []= $elem1091;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\MetaException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_listTableNodeDists_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter1092)
          {
            $xfer += $iter1092->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_assiginSchematoDB_args {
  static $_TSPEC;

  public $dbName = null;
  public $schemaName = null;
  public $fileSplitKeys = null;
  public $part_keys = null;
  public $ngs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'dbName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'schemaName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'fileSplitKeys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        4 => array(
          'var' => 'part_keys',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\FieldSchema',
            ),
          ),
        5 => array(
          'var' => 'ngs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\metastore\NodeGroup',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['dbName'])) {
        $this->dbName = $vals['dbName'];
      }
      if (isset($vals['schemaName'])) {
        $this->schemaName = $vals['schemaName'];
      }
      if (isset($vals['fileSplitKeys'])) {
        $this->fileSplitKeys = $vals['fileSplitKeys'];
      }
      if (isset($vals['part_keys'])) {
        $this->part_keys = $vals['part_keys'];
      }
      if (isset($vals['ngs'])) {
        $this->ngs = $vals['ngs'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_assiginSchematoDB_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dbName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->schemaName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->fileSplitKeys = array();
            $_size1093 = 0;
            $_etype1096 = 0;
            $xfer += $input->readListBegin($_etype1096, $_size1093);
            for ($_i1097 = 0; $_i1097 < $_size1093; ++$_i1097)
            {
              $elem1098 = null;
              $elem1098 = new \metastore\FieldSchema();
              $xfer += $elem1098->read($input);
              $this->fileSplitKeys []= $elem1098;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->part_keys = array();
            $_size1099 = 0;
            $_etype1102 = 0;
            $xfer += $input->readListBegin($_etype1102, $_size1099);
            for ($_i1103 = 0; $_i1103 < $_size1099; ++$_i1103)
            {
              $elem1104 = null;
              $elem1104 = new \metastore\FieldSchema();
              $xfer += $elem1104->read($input);
              $this->part_keys []= $elem1104;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->ngs = array();
            $_size1105 = 0;
            $_etype1108 = 0;
            $xfer += $input->readListBegin($_etype1108, $_size1105);
            for ($_i1109 = 0; $_i1109 < $_size1105; ++$_i1109)
            {
              $elem1110 = null;
              $elem1110 = new \metastore\NodeGroup();
              $xfer += $elem1110->read($input);
              $this->ngs []= $elem1110;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_assiginSchematoDB_args');
    if ($this->dbName !== null) {
      $xfer += $output->writeFieldBegin('dbName', TType::STRING, 1);
      $xfer += $output->writeString($this->dbName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->schemaName !== null) {
      $xfer += $output->writeFieldBegin('schemaName', TType::STRING, 2);
      $xfer += $output->writeString($this->schemaName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileSplitKeys !== null) {
      if (!is_array($this->fileSplitKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fileSplitKeys', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->fileSplitKeys));
        {
          foreach ($this->fileSplitKeys as $iter1111)
          {
            $xfer += $iter1111->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->part_keys !== null) {
      if (!is_array($this->part_keys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('part_keys', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->part_keys));
        {
          foreach ($this->part_keys as $iter1112)
          {
            $xfer += $iter1112->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ngs !== null) {
      if (!is_array($this->ngs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ngs', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->ngs));
        {
          foreach ($this->ngs as $iter1113)
          {
            $xfer += $iter1113->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftHiveMetastore_assiginSchematoDB_result {
  static $_TSPEC;

  public $success = null;
  public $o1 = null;
  public $o2 = null;
  public $o3 = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'o1',
          'type' => TType::STRUCT,
          'class' => '\metastore\InvalidObjectException',
          ),
        2 => array(
          'var' => 'o2',
          'type' => TType::STRUCT,
          'class' => '\metastore\NoSuchObjectException',
          ),
        3 => array(
          'var' => 'o3',
          'type' => TType::STRUCT,
          'class' => '\metastore\MetaException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['o1'])) {
        $this->o1 = $vals['o1'];
      }
      if (isset($vals['o2'])) {
        $this->o2 = $vals['o2'];
      }
      if (isset($vals['o3'])) {
        $this->o3 = $vals['o3'];
      }
    }
  }

  public function getName() {
    return 'ThriftHiveMetastore_assiginSchematoDB_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->o1 = new \metastore\InvalidObjectException();
            $xfer += $this->o1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->o2 = new \metastore\NoSuchObjectException();
            $xfer += $this->o2->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->o3 = new \metastore\MetaException();
            $xfer += $this->o3->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftHiveMetastore_assiginSchematoDB_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o1 !== null) {
      $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
      $xfer += $this->o1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o2 !== null) {
      $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
      $xfer += $this->o2->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->o3 !== null) {
      $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
      $xfer += $this->o3->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


